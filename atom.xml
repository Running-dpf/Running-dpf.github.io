<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nayaur&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/3d942ec2e3778107ccc80fb56434e192</icon>
  <subtitle>我走的很慢，但我从不后退</subtitle>
  <link href="https://running-dpf.github.io/atom.xml" rel="self"/>
  
  <link href="https://running-dpf.github.io/"/>
  <updated>2021-09-18T09:55:47.064Z</updated>
  <id>https://running-dpf.github.io/</id>
  
  <author>
    <name>岩羊</name>
    <email>please_dpf@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>du</title>
    <link href="https://running-dpf.github.io/2021/09/18/du-md/"/>
    <id>https://running-dpf.github.io/2021/09/18/du-md/</id>
    <published>2021-09-18T08:44:44.000Z</published>
    <updated>2021-09-18T09:55:47.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="du"><a href="#du" class="headerlink" title="du"></a>du</h1><p>du(Disk Usage) - 报告磁盘空间使用情况</p><span id="more"></span><pre class="line-numbers language-none"><code class="language-none">-a, --all    显示对所有文件的统计，而不只是包含子目录。-b, --bytes    输出以字节为单位的大小，替代缺省时1024字节的计数单位。--block-size&#x3D;size    输出以块为单位的大小，块的大小为 size 字节。( file- utils-4.0 的新选项)-c, --total    在处理完所有参数后给出所有这些参数的总计。这个选项被 用给出指定的一组文件或目录使用的空间的总和。-D, --dereference-args    引用命令行参数的符号连接。但不影响其他的符号连接。 这对找出象 &#x2F;usr&#x2F;tmp 这样的目录的磁盘使用量有用， &#x2F;usr&#x2F;tmp 等通常是符号连接。 译住：例如在 &#x2F;var&#x2F;tmp 下建立一个目录test, 而&#x2F;usr&#x2F;tmp 是指向 &#x2F;var&#x2F;tmp 的符号连接。du &#x2F;usr&#x2F;tmp 返回一项 &#x2F;usr&#x2F;tmp , 而 du - D &#x2F;usr&#x2F;tmp 返回两项 &#x2F;usr&#x2F;tmp，&#x2F;usr&#x2F;tmp&#x2F;test。--exclude&#x3D;pattern    在递归时，忽略与指定模式相匹配的文件或子目录。模式 可以是任何 Bourne shell 的文件 glob 模式。( file- utils-4.0 的新选项)-h, --human-readable    为每个数附加一个表示大小单位的字母，象用M表示二进制 的兆字节。-H, --si    与 -h 参数起同样的作用，只是使用法定的 SI 单位( 用 1000的幂而不是 1024 的幂，这样 M 代表的就是1000000 而不是 1048576)。(fileutils-4.0 的新选项)-k, --kilobytes    输出以1024字节为计数单位的大小。-l, --count-links    统计所有文件的大小，包括已经被统计过的(作为一个硬连接)。-L, --dereference    引用符号连接(不是显示连接点本身而是连接指向的文件或 目录所使用的磁盘空间)。-m, --megabytes    输出以兆字节的块为计数单位的大小(就是 1,048,576 字节)。--max-depth&#x3D;n    只输出命令行参数的小于等于第 n 层的目录的总计。 --max-depth&#x3D;0的作用同于-s选项。(fileutils-4.0的新选项)-s, --summarize    对每个参数只显示总和。-S, --separate-dirs    单独报告每一个目录的大小，不包括子目录的大小。-x, --one-file-system    忽略与被处理的参数不在同一个文件系统的目录。-X file, --exclude-from&#x3D;file    除了从指定的文件中得到模式之外与 --exclude 一样。 模式以行的形式列出。如果指定的文件是&#39;-&#39;,那么从标准输 入中读出模式。(fileutils-4.0 的新选项) GNU 标准选项--help    在标准输出上输出帮助信息后正常退出。--version    在标准输出上输出版本信息后正常退出。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>统计当前目录下，第一层的文件大小</li></ul><pre class="line-numbers language-none"><code class="language-none">du -ah --max-depth&#x3D;1 .&#x2F;cdn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>统计当前目录大小，并安大小排序</li></ul><pre class="line-numbers language-none"><code class="language-none">du -sm * | sort -n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>按大小排序目录(查看文件目录大小)</li></ul><pre class="line-numbers language-none"><code class="language-none">du -h --time --max-depth&#x3D;1 | sort -hr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>列出当前目录中的目录名不包括xyz字符串的目录的大小</li></ul><pre class="line-numbers language-none"><code class="language-none">du -h --exclude&#x3D;&#39;*xyz*&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>显示几个文件或目录各自占用磁盘空间的大小，并统计它们的总和</li></ul><pre class="line-numbers language-none"><code class="language-none">du -c log30.tar.gz log31.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看各文件夹大小命令</li></ul><pre class="line-numbers language-none"><code class="language-none">du -h --max-depth&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;du&quot;&gt;&lt;a href=&quot;#du&quot; class=&quot;headerlink&quot; title=&quot;du&quot;&gt;&lt;/a&gt;du&lt;/h1&gt;&lt;p&gt;du(Disk Usage) - 报告磁盘空间使用情况&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://running-dpf.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://running-dpf.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx禁止外部访问到隐藏文件（.git或.env）</title>
    <link href="https://running-dpf.github.io/2021/06/03/nginx-deny-git/"/>
    <id>https://running-dpf.github.io/2021/06/03/nginx-deny-git/</id>
    <published>2021-06-03T03:21:29.000Z</published>
    <updated>2021-06-03T03:25:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安全部门说线上有域名可以直接下载到.env文件，这类文件中是有数据库等账号信息，所以需要隐藏掉</p><span id="more"></span><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在server的配置中，加上以下这段，重新reload即可</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">location ~ &#x2F;\. &#123;        deny all;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;安全部门说线上有域名可以直接下载到.env文件，这类文件中是有数据库等账号信息，所以需要隐藏掉&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="https://running-dpf.github.io/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://running-dpf.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>php-fpm配置文件详解</title>
    <link href="https://running-dpf.github.io/2021/06/01/php-fpm-conf/"/>
    <id>https://running-dpf.github.io/2021/06/01/php-fpm-conf/</id>
    <published>2021-06-01T10:19:46.000Z</published>
    <updated>2021-06-02T05:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>php一直都搞不懂，今天彻底把php-fpm的配置文件解释一下</p><span id="more"></span><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><pre class="line-numbers language-none"><code class="language-none">[www]user &#x3D; wwwgroup &#x3D; www;listen &#x3D; 127.0.0.1:9000listen.owner &#x3D; wwwlisten.group &#x3D; wwwlisten.mode &#x3D; 0660listen &#x3D; &#x2F;dev&#x2F;shm&#x2F;php-fpm.socklisten.allowed_clients &#x3D; 127.0.0.1;pm &#x3D; staticpm &#x3D; dynamicpm.max_children &#x3D; 40pm.start_servers &#x3D; 20pm.min_spare_servers &#x3D; 20pm.max_spare_servers &#x3D; 40pm.max_requests &#x3D; 128;pm.max_requests &#x3D; 500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>1、pm = dynamic 或 pm = static 表示使用哪种进程数量管理方式，dynamic表示php-fpm进程数是动态的，最开始是pm.start_servers指定的数量，如果请求较多，则会自动增加，保证空闲的进程数不小于pm.min_spare_servers，如果进程数较多，也会进行相应清理，保证多余的进程数不多于pm.max_spare_servers；</p><p>2、pm.max_children：静态方式下开启的php-fpm进程数量，在动态方式下他限定php-fpm的最大进程数(<font color="red">这里要注意pm.max_spare_servers的值只能小于等于pm.max_children</font>）<br>pm.start_servers：动态方式下的起始php-fpm进程数量。<br>pm.min_spare_servers：动态方式空闲状态下的最小php-fpm进程数量。<br>pm.max_spare_servers：动态方式空闲状态下的最大php-fpm进程数量。</p><p>区别：</p><p>如果dm设置为static，那么其实只有pm.max_children这个参数生效。系统会开启设置数量的php-fpm进程。</p><p>如果dm设置为dynamic，那么pm.max_children参数失效，后面3个参数生效。系统会在php-fpm运行开始的时候启动pm.start_servers个php-fpm进程，然后根据系统的需求动态在pm.min_spare_servers和pm.max_spare_servers之间调整php-fpm进程数。</p><p>设置：</p><p>数值设置，参考自己的实际硬件配置，可以参考 总内存/30M 来计算。</p><h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p>如何判断我选择“pm = dynamic”还是“pm = static”呢？哪一种更好呢？</p><p>事实上，跟Apache一样，运行的PHP程序在执行完成后，或多或少会有内存泄露的问题。</p><p>这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20-30M的原因了。</p><p>对于内存大的服务器（比如8G以上）来说，用静态的max_children实际上更为妥当，因为这样不需要进行额外的进程数目控制，会提高效率。因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量也可以根据 总内存/30M 得到，比如8GB内存可以设置为100，那么php-fpm耗费的内存就能控制在 2G-3G的样子。</p><p>如果内存稍微小点，比如1~2G，那么指定静态的进程数量更加有利于服务器的稳定。这样可以保证php-fpm只获取够用的内存，将不多的内存分配给其他应用去使用，会使系统的运行更加畅通。</p><p>对于小内存的服务器来说，比如256M内存的VPS，即使按照一个20M的内存量来算，10个php-cgi进程就将耗掉200M内存，那系统的崩溃就应该很正常了。</p><p>因此应该尽量地控制php-fpm进程的数量，大体明确其他应用占用的内存后，给它指定一个静态的小数量，会让系统更加平稳一些。</p><p>或者使用动态方式，因为动态方式会结束掉多余的进程，可以回收释放一些内存，所以推荐在内存较少的服务器或VPS上使用，具体最大数量根据 总内存/20M 得到。</p><p>比如说512M的VPS，建议pm.max_spare_servers设置为20。至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比较合适的值在5~10之间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结：内存小的建议用动态（pm = dynamic），内存大的建议用静态（pm = static）</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;php一直都搞不懂，今天彻底把php-fpm的配置文件解释一下&lt;/p&gt;</summary>
    
    
    
    <category term="php" scheme="https://running-dpf.github.io/categories/php/"/>
    
    
    <category term="php" scheme="https://running-dpf.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php进程不及时释放进程导致CPU跑满</title>
    <link href="https://running-dpf.github.io/2021/06/01/php-cpu/"/>
    <id>https://running-dpf.github.io/2021/06/01/php-cpu/</id>
    <published>2021-06-01T10:08:43.000Z</published>
    <updated>2021-06-02T06:10:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司一台服务器安装了php，很稳定的跑了3年，突然有一天CPU报警，排查为php-fpm进程CPU利用率为100%，遂排查原因</p><span id="more"></span><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>php-fpm进程不但占用内存，也会占用cpu。实际服务器运行观察中，我们可能经常发现这种现象，内存占用很少，cpu却跑满了，导致运行堵塞。当然，出现这种情况的原因可能有多种，一种原因就是php进程没有得到及时释放。</p><p>对于这种情况，可以设置最大请求数max_requests，即当一个 PHP-CGI 进程处理的请求数累积到 max_requests 个后，则自动重启该进程，这样达到了释放内存的目的了，当然cpu占用也同步降低了。</p><p>以4G内存服务器为例进行设置，加入FPM配置文件：<br>pm.max_requests = 128<br>pm.max_children = 20 #表示 php-fpm 能启动的子进程的最大数量<br>当然，以上数值应该根据需要测试调整。</p><p>以上参数可以参考这个文章 <a href="http://localhost:4000/2021/06/01/php-fpm-conf/">php-fpm的配置文件详解</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公司一台服务器安装了php，很稳定的跑了3年，突然有一天CPU报警，排查为php-fpm进程CPU利用率为100%，遂排查原因&lt;/p&gt;</summary>
    
    
    
    <category term="php" scheme="https://running-dpf.github.io/categories/php/"/>
    
    
    <category term="php" scheme="https://running-dpf.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>ISP</title>
    <link href="https://running-dpf.github.io/2021/05/28/ISP/"/>
    <id>https://running-dpf.github.io/2021/05/28/ISP/</id>
    <published>2021-05-28T05:33:32.000Z</published>
    <updated>2021-05-28T05:36:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>互联网服务提供商（Internet Service Provider），简称ISP，指的是面向公众提供下列信息服务的经营者：一是接入服务，即帮助用户接入Internet；二是导航服务，即帮助用户在Internet上找到所需要的信息；三是信息服务，即建立数据服务系统，收集、加工、存储信息，定期维护更新，并通过网络向用户提供信息内容服务。</p><span id="more"></span><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>在互联网的定义部分就已经接触到，互联网是连接了众多网络的世界级规模的网络。并且，所连接的网络不是杂乱的表现，是通过主干网的互联网服务提供商（ISP）之间的相互连接而构成的互联网。<br>ISP是具有与互联网间保持连续连接的环境，并且将该环境向一般大众提供的行为，我们通过访问ISP能够实现与互联网的连接（而不同的ISP提供的访问环境会有所不同）。<br>并且有根据ISP是直接与主干网连接，还是通过与主干网直接连接的ISP间接与主干网连接来进行分类的。前者称为一级提供商，而后者称为二级提供商（也有三级提供商）。<br>调制解调器（Modem，俗称“猫”）接入方式。<br>Modem是MOdulatorDEModulator两个英文的缩写合并而成。译成中文就是“调制解调器”，台湾地区也称其为“数据机”或“魔电”。Modem的主要功能就是将数据在数字信号和模拟信号之间的转换，以实现在电话线上的传输。<br>这种接入方式就是通常所说的拨号上网方式，是大家最熟悉和家庭上网应用最多的一种上网方式。主机通过调制解调器和电话线路与ISP（互联网服务提供商）网络服务器的调制解调器相连，实现主机与网络服务器的连接。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;互联网服务提供商（Internet Service Provider），简称ISP，指的是面向公众提供下列信息服务的经营者：一是接入服务，即帮助用户接入Internet；二是导航服务，即帮助用户在Internet上找到所需要的信息；三是信息服务，即建立数据服务系统，收集、加工、存储信息，定期维护更新，并通过网络向用户提供信息内容服务。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://running-dpf.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://running-dpf.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>wireshark合并多个pacp文件</title>
    <link href="https://running-dpf.github.io/2021/05/27/wireshark-merge/"/>
    <id>https://running-dpf.github.io/2021/05/27/wireshark-merge/</id>
    <published>2021-05-27T02:21:10.000Z</published>
    <updated>2021-05-27T02:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当出现网络问题的时候，可能会抓很多个pcap包，当分析的时候时间点很不容易查找，所以要将多个pcap包合并为一个，方便我们运维人员查找</p><span id="more"></span><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>macos命令</p><p>cd /Applications/Wireshark.app/Contents/MacOS</p><p>./mergecap -w ~/Downloads/compare.pcap ~/Downloads/*.pcap</p><p>这样，我们在Downloads文件夹能看到一个compare.pcap的文件，这就是整合的pacp文件</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当出现网络问题的时候，可能会抓很多个pcap包，当分析的时候时间点很不容易查找，所以要将多个pcap包合并为一个，方便我们运维人员查找&lt;/p&gt;</summary>
    
    
    
    <category term="wireshark 网络" scheme="https://running-dpf.github.io/categories/wireshark-%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="wireshark" scheme="https://running-dpf.github.io/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>mac使用crt异常报错</title>
    <link href="https://running-dpf.github.io/2021/05/20/mac-crt/"/>
    <id>https://running-dpf.github.io/2021/05/20/mac-crt/</id>
    <published>2021-05-20T07:50:48.000Z</published>
    <updated>2021-06-04T03:49:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刚刚升级完mac系统：macOS Catalina，使用CRT就有报错，但是不影响我们使用，只是每次启动都会报错，很烦人。</p><p>报错内容是The permissions on the “/cores” directory need to be changed to include write permission for “other”。</p><span id="more"></span><p>Please execute (or ask an admin to execute) the following from a terminal window:</p><p>sudo chmod o+w /cores</p><p>You can change this behavior by setting the “Create Core Files” parameter in your “Global.ini” to 0.</p><img src="/2021/05/20/mac-crt/img/image-20210520160622429.png" alt="报错截图" style="zoom:50%;"><p>见证一下mac系统</p><img src="/2021/05/20/mac-crt/img/image-20210520160642626.png" alt="mac截图" style="zoom:50%;"><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>根据提示执行：</p><p>查看下我们本机的 cores 目录权限</p><pre class="line-numbers language-none"><code class="language-none">ls -l &#x2F;...drwxr-xr-x    2 root  wheel    64 12  14 2019 cores...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>发现缺少写权限，所以执行</p><pre class="line-numbers language-none"><code class="language-none">sudo chmod o+w &#x2F;coresPassword:ls -l &#x2F;...drwxr-xrwx    2 root  wheel    64 12  14 2019 cores...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再去启动CRT就正常了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;刚刚升级完mac系统：macOS Catalina，使用CRT就有报错，但是不影响我们使用，只是每次启动都会报错，很烦人。&lt;/p&gt;
&lt;p&gt;报错内容是The permissions on the “/cores” directory need to be changed to include write permission for “other”。&lt;/p&gt;</summary>
    
    
    
    <category term="Mac" scheme="https://running-dpf.github.io/categories/Mac/"/>
    
    
    <category term="mac" scheme="https://running-dpf.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Linux下设置swappiness参数来配置内存使用到多少才开始使用swap分区</title>
    <link href="https://running-dpf.github.io/2021/05/20/swappiness/"/>
    <id>https://running-dpf.github.io/2021/05/20/swappiness/</id>
    <published>2021-05-20T06:52:32.000Z</published>
    <updated>2021-05-28T09:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>阿里云 ECS的 CPU 使用率有时候到100%，top 命令查看进程发现是 kswapd0 进程占 cpu 达到70%。</p><span id="more"></span><p>swap分区的作用是当物理内存不足时，会将一部分硬盘当做虚拟内存来使用。</p><p>kswapd0 占用过高是因为 物理内存不足，使用swap分区与内存换页操作交换数据，导致CPU占用过高。<br>swap分区的介绍可以看这个文章：<a href="https://running-dpf.github.io/2021/05/20/swap/">swap分区</a></p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>swappiness的值的大小对如何使用swap分区是有着很大的联系的。swappiness=0的时候表示最大限度使用物理内存，然后才是swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。linux的基本默认设置为60，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness#60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也就是说，你的内存在使用到 100-60=40% 的时候，就开始出现有交换分区的使用。大家知道，内存的速度会比磁盘快很多，这样子会加大系统IO，同时造的成大量页的换进换出，严重影响系统的性能，所以我们在操作系统层面，要尽可能使用内存，对该参数进行调整。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>临时调整的方法如下，我们调成10：</p><pre class="line-numbers language-none"><code class="language-none">sysctl vm.swappiness&#x3D;10#vm.swappiness&#x3D;10cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness#10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这只是临时调整的方法，重启后会回到默认设置的.</p><p>要想永久调整的话，需要在/etc/sysctl.conf修改，加上：</p><pre class="line-numbers language-none"><code class="language-none">sudo vim &#x2F;etc&#x2F;sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加上</p><pre class="line-numbers language-none"><code class="language-none"># Controls the maximum number of shared memory segments, in pageskernel.shmall &#x3D; 4294967296 #这一个可以不用设置vm.swappiness &#x3D; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 生效</p><pre class="line-numbers language-none"><code class="language-none">sudo sysctl -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样便完成修改设置！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;阿里云 ECS的 CPU 使用率有时候到100%，top 命令查看进程发现是 kswapd0 进程占 cpu 达到70%。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://running-dpf.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://running-dpf.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>swap分区介绍</title>
    <link href="https://running-dpf.github.io/2021/05/20/swap/"/>
    <id>https://running-dpf.github.io/2021/05/20/swap/</id>
    <published>2021-05-20T06:39:55.000Z</published>
    <updated>2021-05-20T06:51:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wap交换分区概念"><a href="#wap交换分区概念" class="headerlink" title="wap交换分区概念"></a>wap交换分区概念</h2><p>什么是Linux swap space呢？我们先来看看下面两段关于Linux swap space的英文介绍资料:</p><p>Linux divides its physical RAM (random access memory) into chucks of memory called pages. Swapping is the process whereby a page of memory is copied to the preconfigured space on the hard disk, called swap space, to free up that page of memory. The combined sizes of the physical memory and the swap space is the amount of virtual memory available.</p><p>Swap space in Linux is used when the amount of physical memory (RAM) is full. If the system needs more memory resources and the RAM is full, inactive pages in memory are moved to the swap space. While swap space can help machines with a small amount of RAM, it should not be considered a replacement for more RAM. Swap space is located on hard drives, which have a slower access time than physical memory.Swap space can be a dedicated swap partition (recommended), a swap file, or a combination of swap partitions and swap files.</p><span id="more"></span><p>Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这部分内存就是 Cache Memory（缓存内存）。即使你的程序运行结束后，Cache Memory 也不会自动释放。这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存变少。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到swap空间中，等到那些程序要运行时，再从 swap 分区中恢复保存的数据到内存中。这样，系统在物理内存不够时，才进行 swap 交换。</p><p>关于 swap 分区，其实我们有很多疑问,如果能弄清楚这些疑问，那么你对 swap 的了解掌握就差不多了。如何查看 swap 分区大小？ swap 分区大小应该如何设置？系统在什么时候会使用 swap 分区? 是否可以调整？ 如何调整 swap 分区的大小？ swap 分区有什么优劣和要注意的地方？ swap 分区是否必要？那么我一个一个来看看这些疑问吧！</p><h2 id="查看swap分区大小"><a href="#查看swap分区大小" class="headerlink" title="查看swap分区大小"></a>查看swap分区大小</h2><p>查看swap分区的大小以及使用情况，一般使用free -m命令即可，如下所示，swap大小为2015M，目前没有使用swap分区<img src="/2021/05/20/swap/img/image-20210520144425159.png" alt="未使用swap"></p><h2 id="wap分区大小设置"><a href="#wap分区大小设置" class="headerlink" title="wap分区大小设置"></a><strong>wap分区大小设置</strong></h2><p>系统的swap分区大小设置多大才是最优呢？ 关于这个问题，应该说只能有一个统一的参考标准，具体还应该根据系统实际情况和内存的负荷综合考虑，像ORACLE的官方文档就推荐如下设置，这个是根据物理内存来做参考的。</p><p><img src="/2021/05/20/swap/img/image-20210520144633150.png" alt="image-20210520144633150"></p><p>另外在其它博客中看到下面一个推荐设置，当然我不清楚其怎么得到这个标准的。是否合理也无从考证。可以作为一个参考。</p><p>4G以内的物理内存，SWAP 设置为内存的2倍。</p><p>4-8G的物理内存，swap 等于内存大小。</p><p>8-64G 的物理内存，swap 设置为8G。</p><p>64-256G物理内存，swap 设置为16G。</p><p>上下两个标准确实也很让人无所适从。我就有一次在一台ORACLE数据库服务器（64G的RAM），按照官方推荐设置了一个很大的swap分区，但是我发现其实这个swap几乎很少用到，其实是浪费了磁盘空间。所以如果根据系统实际情况和内存的负荷综合考虑，其实应该按照第二个参考标准设置为8G即可。当然这个只是个人的一些认知。</p><h2 id="释放swap分区空间"><a href="#释放swap分区空间" class="headerlink" title="释放swap分区空间"></a><strong>释放swap分区空间</strong></h2><p>查看swap分区位置</p><p><img src="/2021/05/20/swap/img/image-20210520144815788.png" alt="image-20210520144815788"></p><p>用swapoff关闭交换分区</p><p><code>swapoff /dev/mapper/VolGroup00-LogVol01</code></p><p>使用swapon启用交换分区**，此时查看交换分区的使用情况，你会发现used为0了</p><p><img src="/2021/05/20/swap/img/image-20210520144920381.png" alt="image-20210520144920381"></p><h2 id="Swap分区空间什么时候使用"><a href="#Swap分区空间什么时候使用" class="headerlink" title="Swap分区空间什么时候使用"></a>Swap分区空间什么时候使用</h2><p>系统在什么情况或条件下才会使用swap分区的空间呢？ 其实是Linux通过一个参数swappiness来控制的。当然还涉及到复杂的算法。</p><p>这个参数值可为 0-100，控制系统 swap 的使用程度。高数值可优先系统性能，在进程不活跃时主动将其转换出物理内存。低数值可优先互动性并尽量避免将进程转换处物理内存，并降低反应延迟。默认值为 60。注意：这个只是一个权值，不是一个百分比值，涉及到系统内核复杂的算法。下面是关于swappiness的相关资料：</p><p>The Linux 2.6 kernel added a new kernel parameter called swappiness to let administrators tweak the way Linux swaps. It is a number from 0 to 100. In essence, higher values lead to more pages being swapped, and lower values lead to more applications being kept in memory, even if they are idle. Kernel maintainer Andrew Morton has said that he runs his desktop machines with a swappiness of 100, stating that “My point is that decreasing the tendency of the kernel to swap stuff out is wrong. You really don’t want hundreds of megabytes of BloatyApp’s untouched memory floating about in the machine. Get it out on the disk, use the memory for something useful.”</p><p>Swappiness is a property of the Linux kernel that changes the balance between swapping out runtime memory, as opposed to dropping pages from the system page cache. Swappiness can be set to values between 0 and 100 inclusive. A low value means the kernel will try to avoid swapping as much as possible where a higher value instead will make the kernel aggressively try to use swap space. The default value is 60, and for most desktop systems, setting it to 100 may affect the overall performance, whereas setting it lower (even 0) may improve interactivity (by decreasing response latency.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;wap交换分区概念&quot;&gt;&lt;a href=&quot;#wap交换分区概念&quot; class=&quot;headerlink&quot; title=&quot;wap交换分区概念&quot;&gt;&lt;/a&gt;wap交换分区概念&lt;/h2&gt;&lt;p&gt;什么是Linux swap space呢？我们先来看看下面两段关于Linux swap space的英文介绍资料:&lt;/p&gt;
&lt;p&gt;Linux divides its physical RAM (random access memory) into chucks of memory called pages. Swapping is the process whereby a page of memory is copied to the preconfigured space on the hard disk, called swap space, to free up that page of memory. The combined sizes of the physical memory and the swap space is the amount of virtual memory available.&lt;/p&gt;
&lt;p&gt;Swap space in Linux is used when the amount of physical memory (RAM) is full. If the system needs more memory resources and the RAM is full, inactive pages in memory are moved to the swap space. While swap space can help machines with a small amount of RAM, it should not be considered a replacement for more RAM. Swap space is located on hard drives, which have a slower access time than physical memory.Swap space can be a dedicated swap partition (recommended), a swap file, or a combination of swap partitions and swap files.&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://running-dpf.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://running-dpf.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>NGINX禁止解析IP访问</title>
    <link href="https://running-dpf.github.io/2021/05/20/NGINX-Prohibit-IP-access/"/>
    <id>https://running-dpf.github.io/2021/05/20/NGINX-Prohibit-IP-access/</id>
    <published>2021-05-20T05:56:14.000Z</published>
    <updated>2021-05-20T05:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx配置禁止ip访问，只能域名访问，这样可以增加一定的安全性，并且在nginx内配置80跳转443，或者在公有云负载均衡配置。</p><span id="more"></span><h1 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a>配置如下</h1><pre class="line-numbers language-none"><code class="language-none">server&#123; listen 80 default; server_name _; return 404; &#125;server &#123;listen 80;server_name xxx;rewrite ^(.*)$ https:&#x2F;&#x2F;$&#123;server_name&#125;$1 permanent;&#125;server &#123;listen 443;server_name xxx;    #ssl_certificate ;    #ssl_certificate_key ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;nginx配置禁止ip访问，只能域名访问，这样可以增加一定的安全性，并且在nginx内配置80跳转443，或者在公有云负载均衡配置。&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="https://running-dpf.github.io/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://running-dpf.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Write-Ahead Log（WAL）的工作原理</title>
    <link href="https://running-dpf.github.io/2021/05/13/WAL/"/>
    <id>https://running-dpf.github.io/2021/05/13/WAL/</id>
    <published>2021-05-13T03:16:54.000Z</published>
    <updated>2021-05-20T06:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在存储系统的运行过程中，每时每刻都发生着数据的更新，背后意味着诸如创建，删除，修改文件等数据的操作。抛开物理文件数据的改变，对于中心控制节点而言，这些都会涉及到元数据的更新操作。而为了保持系统元数据和物理数据间的状态一致性，系统所有的数据操作对应的元数据变更都需要持久化到元数据db内，但其实这里有一个性能问题，我们的每次变更如果都要实时同步到外部db内，是否意味着高频的io操作？是否有延时写入的手段呢？本文将要阐述的预写式日志Write Ahead Log(WAL),正是对此的优化。</p><span id="more"></span><h2 id="Write-Ahead-Log概述"><a href="#Write-Ahead-Log概述" class="headerlink" title="Write Ahead Log概述"></a>Write Ahead Log概述</h2><p>Write Ahead Log简称WAL，在分布式存储系统中的元数据更新中应用得十分广泛。WAL的主要意思是说在将元数据的变更操作写入到持久稳定的db之前，先预先写入到一个log中，然后再由另外的操作将log apply到外部的持久db里去。这种模式会减少掉每次的db写入操作，尤其当系统要处理大量的transaction操作的时候，WAL的方式相比较于实时同步db的方式有着更高的效率。</p><p>WAL还有一点很重要的帮助是可以在disaster recovery过程中起到状态恢复的作用，系统在load完元数据db后，再把未来得及提交的WAL apply进来，就能恢复成和之前最终一致的状态。</p><h2 id="WAL的执行机理"><a href="#WAL的执行机理" class="headerlink" title="WAL的执行机理"></a>WAL的执行机理</h2><p>上面只介绍了WAL的概述内容，本小节我们来深入了解WAL的内部执行细节。</p><p>首先我们要搞清楚一点的是，WAL不记录元数据的本身，而是变更的record。那么何为”变更的record“？一个删除操作记录，一个添加记录，至于每个记录会包含有什么信息呢，大家可以参考audit log的内容属性。不过WAL的log格式和audit log还是有所区别的。</p><p>追本溯源，对于WAL来说，它是被谁写入的呢？答案是WAL buffer，当这个buffer满了的时候或者人工触发flush动作时，它就会将transaction数据写出到WAL的log内。当然，系统在每次完成一个操作时，同时会将改动应用到memory和WAL buffer内，然后自己再控制buffer flush出去的逻辑。</p><p>当老的WAL已经被apply进元数据db之后，我们会用更新commitId来表明当前最新的transaction，理论上来说低于这个commitId的WAL已经可以被清除purge出去了。这个过程我们可以理解为checkpoint过程，当前db+WAL变更=新的db。</p><p>上述WAL细节过程如下图:</p><p><img src="/2021/05/13/WAL/image-20210520142356234.png" alt="image-20210520142356234"></p><h2 id="WAL-apply的控制"><a href="#WAL-apply的控制" class="headerlink" title="WAL apply的控制"></a>WAL apply的控制</h2><p>在系统做disaster recovery中，对于WAL的应用过程，有时可能会出现应用出差的情况，包括一些局部WAL记录格式写异常的情况。这个时候用户可以选择是否中断WAL的apply过程或者是忽略异常，来完成尽可能的数据状态恢复。这些都是WAL内部的细节控制。</p><p>以上就是本文主要阐述的关于WAL的内容了。<br>#引用<br>[1].<a href="https://pgadminedb.readthedocs.io/en/latest/module_02/">https://pgadminedb.readthedocs.io/en/latest/module_02/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在存储系统的运行过程中，每时每刻都发生着数据的更新，背后意味着诸如创建，删除，修改文件等数据的操作。抛开物理文件数据的改变，对于中心控制节点而言，这些都会涉及到元数据的更新操作。而为了保持系统元数据和物理数据间的状态一致性，系统所有的数据操作对应的元数据变更都需要持久化到元数据db内，但其实这里有一个性能问题，我们的每次变更如果都要实时同步到外部db内，是否意味着高频的io操作？是否有延时写入的手段呢？本文将要阐述的预写式日志Write Ahead Log(WAL),正是对此的优化。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://running-dpf.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="WAL" scheme="https://running-dpf.github.io/tags/WAL/"/>
    
  </entry>
  
  <entry>
    <title>Git 如何 clone 非 master 分支的代码</title>
    <link href="https://running-dpf.github.io/2021/05/08/git-clone-not-master-branch/"/>
    <id>https://running-dpf.github.io/2021/05/08/git-clone-not-master-branch/</id>
    <published>2021-05-08T09:05:22.546Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们每次使用命令</p><pre class="line-numbers language-none"><code class="language-none">git clone git@gitlab.xxx.com:xxxxx.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认 clone 的是这个仓库的 master 分支。如果最新的代码不在 master 分支上，该如何拿到呢？如下图所示，最新的代码可能在<code>daily/1.4.1</code>分支上，我们希望拿到这个分支上的代码。</p><span id="more"></span><p><img src="https://ooo.0o0.ooo/2016/07/07/577e349ab42ed.png" alt="7f07c8f6deef169ef6be5103bbd3e932f8676bb1.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>刚刚开周会的时候，自己洋洋得意的分享我的解决方案，但是……经过与团队成员的的讨论，自己的方法弱爆了，现在把更优雅的方法写一下。原来写的方法并不太适合用在这个场景里。</strong> 我之前写的方法在文章后面。</p><p>直接使用命令</p><pre class="line-numbers language-none"><code class="language-none">git branch -r #查看远程分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-none"><code class="language-none">git branch -a #查看所有分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会显示</p><pre class="line-numbers language-none"><code class="language-none">origin&#x2F;HEAD -&gt; origin&#x2F;masterorigin&#x2F;daily&#x2F;1.2.2origin&#x2F;daily&#x2F;1.3.0origin&#x2F;daily&#x2F;1.4.1origin&#x2F;developorigin&#x2F;feature&#x2F;daily-1.0.0origin&#x2F;master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接</p><pre class="line-numbers language-none"><code class="language-none">git checkout origin&#x2F;daily&#x2F;1.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就好了。。。</p><h2 id="原来的解决方案"><a href="#原来的解决方案" class="headerlink" title="原来的解决方案"></a>原来的解决方案</h2><p><strong>其实我原来写的这个方法更多的是：设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支。</strong></p><p>我们在本地先建立一个分支，建议名称和远程的想要同步的分支名称一样。</p><pre class="line-numbers language-none"><code class="language-none">git branch daily&#x2F;1.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在切换到这个本地分支</p><pre class="line-numbers language-none"><code class="language-none">git checkout daily&#x2F;1.4.1# Switched to branch &#39;daily&#x2F;1.4.1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来就可以去建立上游分支的关联了，但是这个命令比较长，不好记，我们可以直接先<code>pull</code>一下，git 会提示我们相应的操作和命令。</p><pre class="line-numbers language-none"><code class="language-none">git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details.    git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with:    git branch --set-upstream-to&#x3D;origin&#x2F;&lt;branch&gt; daily&#x2F;1.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到最后一行，执行这个命令，即可完成与上游分支的关联。</p><pre class="line-numbers language-none"><code class="language-none">git branch --set-upstream-to&#x3D;origin&#x2F;daily&#x2F;1.4.1 daily&#x2F;1.4.1# Branch daily&#x2F;1.4.1 set up to track remote branch daily&#x2F;1.4.1 from origin.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后再<code>pull</code>一下就好了！</p><pre class="line-numbers language-none"><code class="language-none">git pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;我们每次使用命令&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;git clone git@gitlab.xxx.com:xxxxx.git&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认 clone 的是这个仓库的 master 分支。如果最新的代码不在 master 分支上，该如何拿到呢？如下图所示，最新的代码可能在&lt;code&gt;daily/1.4.1&lt;/code&gt;分支上，我们希望拿到这个分支上的代码。&lt;/p&gt;</summary>
    
    
    
    <category term="GitHub" scheme="https://running-dpf.github.io/categories/GitHub/"/>
    
    
    <category term="GitHub" scheme="https://running-dpf.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记3-方法、毒瘤等</title>
    <link href="https://running-dpf.github.io/2021/05/08/JavaScript-good-parts-note3/"/>
    <id>https://running-dpf.github.io/2021/05/08/JavaScript-good-parts-note3/</id>
    <published>2021-05-08T09:03:43.511Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>这一章主要介绍了一些方法集。这里写几个我不太熟悉的方法和要点吧。</p><span id="more"></span><ul><li><p><code>array.join()</code></p><blockquote><p>对于IE6/7，使用<code>array.join()</code>连接大量字符串的效率确实优于使用<code>+</code>元素运算符。但是目前主流的浏览器，包括IE8以后的版本，都对<code>+</code>元素运算符连接字符串做了特别优化，性能已经显著高于<code>array.join()</code>。</p></blockquote></li><li><p><code>number.toExponential(fractionDigits)</code></p><p>  把这个<code>number</code>转换成一个指数形式的字符串。</p></li><li><p><code>number.toFixed(fractionDigits)</code></p><p>  将这个<code>number</code>转换成一个十进制形式的字符串。</p></li></ul><h2 id="毒瘤"><a href="#毒瘤" class="headerlink" title="毒瘤"></a>毒瘤</h2><ul><li><p>注意全局变量的引入。</p></li><li><p>JavaScript 中 Unicode 是16位的。包含65536个字符（基本多文种平面 Basic Multilingual Plane）。剩下的百万字符中的每一个都可以用一对字符来表示。Unicode 把一对字符视为一个单一的字符，而 JavaScript 认为一对字符是两个不同的字符。</p></li><li><p>检测<code>null</code>的方式。</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">//object</span>myValue <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token comment">//检测 null</span><span class="token keyword">if</span> <span class="token punctuation">(</span>myValue <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> myValue <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// myValue 是一个对象或数组！</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>parseInt</code> 把字符串转化为整数的函数。它遇到非数字时会停止解析，所以<code>parseInt(&#39;16&#39;)</code>和<code>parseInt(&#39;16ton&#39;)</code>产生相同的结果。</p><p>  如果该字符串第一个字符是0，那么该字符串会基于八进制而不是十进制来求职。在八进制中，8和9不是数字，所以<code>parseInt(&#39;08&#39;)</code>和<code>parseInt(&#39;09&#39;)</code>都产生0作为结果。但<code>parseInt()</code>可以接受基数，因此<code>parseInt(&#39;08&#39;,10)</code>结果为8，建议总是加上这个基数参数。</p></li><li><p>JavaScript 的对象永远不会是真的空对象，因为它们可以送原型链中取得成员属性。</p></li></ul><h2 id="糟粕"><a href="#糟粕" class="headerlink" title="糟粕"></a>糟粕</h2><ul><li><p>避免使用<code>with</code>语句。</p></li><li><p>避免使用<code>eval</code>语句。</p></li><li><p><code>continue</code>可能会降低运算性能。</p></li><li><p>位运算符在 JavaScript 会非常慢。</p><p>  Java 里，位运算符处理的是整数。JavaScript 没有整数类型，它只有双精度的浮点数，因此，位运算符把它们的数字运算数先转换为整数，执行运算，在转换回去。JavaScript 的执行环境一般接触不到硬件，所以非常慢。</p></li><li><p>避免使用包装对象。<code>new Object</code>和<code>new Array</code>等。</p></li><li><p>避免使用<code>void</code>。</p></li></ul><p>本系列结束。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。&lt;/p&gt;
&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;p&gt;这一章主要介绍了一些方法集。这里写几个我不太熟悉的方法和要点吧。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用 JavaScript 创建并下载文件</title>
    <link href="https://running-dpf.github.io/2021/05/08/js-create-file-and-download/"/>
    <id>https://running-dpf.github.io/2021/05/08/js-create-file-and-download/</id>
    <published>2021-05-08T09:03:32.347Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。</p><span id="more"></span><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * 创建并下载文件 * @param  &#123;String&#125; fileName 文件名 */</span>    <span class="token keyword">var</span> aTag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    aTag<span class="token punctuation">.</span>download <span class="token operator">=</span> fileName<span class="token punctuation">;</span>    aTag<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>    aTag<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很简单对吧，直接调用这个方法，传入文件名和文件内容，程序新建 a 标签，新建 Blob 对象，将文件名赋给 a 标签，同时将 Blob 对象作为 Url 也赋给 a 标签，模拟点击事件，自动下载成功，最后再回收内存。下面我们来看看具体是怎么操作的。</p><p><img src="https://img.alicdn.com/tfs/TB16.GnOpXXXXXdapXXXXXXXXXX-307-134.png"></p><h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 对象是一个字节序列。拥有 <code>size</code> 和 <code>type</code> 等属性。</p><p>拥有 2 个只读状态 <code>OPEND</code> 和 <code>CLOSED。</code></p><p>Blob 对象属于 JavaScript Web APIs 中的 File API 规定的部分，可以参考 W3C 文档中的 <a href="https://www.w3.org/TR/2015/WD-FileAPI-20150421/#blob"> The Blob Interface and Binary Data</a></p><p>再回来看看我们的代码里是这么写的，使用了 Blob 的构造函数：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">使用方括号的原因是，其构造函数的参数为以下4中：- ArrayBuffer [TypedArrays] elements.- ArrayBufferView [TypedArrays] elements.- Blob elements.- DOMString [WebIDL] elements.所谓 </span><span class="token template-punctuation string">`</span></span>ArrayBuffer<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 是一种用于呈现通用、固定长度的二进制数据的类型。详情可以参考 [ArrayBuffer -MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 以及 [ECMAScript2015 标准中的 ArrayBuffer](http://www.ecma-international.org/ecma-262/6.0/#sec-arraybuffer-objects)。## Blob URLsBlob URLs 被创建或注销是使用 </span><span class="token template-punctuation string">`</span></span><span class="token constant">URL</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 对象上的方法。这个 </span><span class="token template-punctuation string">`</span></span><span class="token constant">URL</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 对象被挂在 </span><span class="token template-punctuation string">`</span></span>Window<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> (HTML) 对象下，或者 </span><span class="token template-punctuation string">`</span></span>WorkerGlobalScope<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> (Web Workers)对象下。拥有以下静态方法 </span><span class="token template-punctuation string">`</span></span>createObjectURL<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 和 </span><span class="token template-punctuation string">`</span></span>revokeObjectURL<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">，用于创建一个 blob 对象的 url 和注销这个 blob url。详情可查看 [关于创建和注销 Blob URL 的 W3C 标准文档]( https://www.w3.org/TR/2015/WD-FileAPI-20150421/#creating-revoking)## 模拟 click</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>jselement<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 W3C 中很早就有这个<a href="https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-2651361">规范</a>，不需要写繁琐的模拟事件触发的代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前我将这个技术使用在 天猫双十一技术和UED庆功会 的摇火箭大屏游戏中。最后的游戏结果排名，在请求了接口后，在前端直接生成并下载到了本地，作为记录保存。主要也是因为服务端暂时没有提供这个一张表去记录游戏结果，于是采用了前端记录的解决方案。</p><p>大家当时都玩的好开心啊，😁。你们的甘其食和全家卡的名单就是这样生成的！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.alloyteam.com/2014/01/use-js-file-download/">在浏览器端用JS创建和下载文件 -alloyteam</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端如何写一个精确的倒计时</title>
    <link href="https://running-dpf.github.io/2021/05/08/how-to-write-a-count-down/"/>
    <id>https://running-dpf.github.io/2021/05/08/how-to-write-a-count-down/</id>
    <published>2021-05-08T09:02:53.561Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。</p><span id="more"></span><p><img src="https://img.alicdn.com/tfs/TB18QnlOpXXXXcVXpXXXXXXXXXX-388-256.png"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>众所周知 setTimeout 或者 setInterval 调用的时候会有微小的误差。有人做了一个 <a href="https://bl.ocks.org/kenpenn/raw/92ebaa71696b4c4c3acd672b1bb3f49a/">demo</a> 来观察这个现象并对其做了修正。短时间的误差倒也可以接受，但是作为一个长时间的倒计时，误差累计就会导致倒计时不准确。</p><p>因此我们可以在获取剩余时间的时候，每次 new 一个设备时间，因为设备时间的流逝相对是准确的，并且如果设备打开了网络时间同步，也会解决这个问题。</p><p>但是，如果用户修改了设备时间，那么整个倒计时就没有意义了，用户只要将设备时间修改为倒计时的 endTime 就可以轻易看到倒计时结束是页面的变化。因此一开始获取服务端时间就是很重要的。</p><p>简单的说，一个简单的精确倒计时原理如下：</p><ul><li>初始化时请求一次服务器时间 serverTime，再 new 一个设备时间 deviceTime</li><li>deviceTime 与 serverTime 的差作为时间偏移修正</li><li>每次递归时 new 一个系统时间，解决 setTimeout 不准确的问题</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>获取剩余时间的代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * 获取剩余时间 * @param  &#123;Number&#125; endTime    截止时间 * @param  &#123;Number&#125; deviceTime 设备时间 * @param  &#123;Number&#125; serverTime 服务端时间 * @return &#123;Object&#125;            剩余时间对象 */</span><span class="token keyword">let</span> <span class="token function-variable function">getRemainTime</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">endTime<span class="token punctuation">,</span> deviceTime<span class="token punctuation">,</span> serverTime</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> t <span class="token operator">=</span> endTime <span class="token operator">-</span> Date<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> serverTime <span class="token operator">+</span> deviceTime    <span class="token keyword">let</span> seconds <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">60</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> minutes <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">60</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> hours <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">24</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> days <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>t <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        <span class="token string">'total'</span><span class="token operator">:</span> t<span class="token punctuation">,</span>        <span class="token string">'days'</span><span class="token operator">:</span> days<span class="token punctuation">,</span>        <span class="token string">'hours'</span><span class="token operator">:</span> hours<span class="token punctuation">,</span>        <span class="token string">'minutes'</span><span class="token operator">:</span> minutes<span class="token punctuation">,</span>        <span class="token string">'seconds'</span><span class="token operator">:</span> seconds    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><del>获取服务器时间可以使用 mtop 接口 <code>mtop.common.getTimestamp</code> </del></p><p>然后可以通过下面的方式来使用：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 获取服务端时间（获取服务端时间代码略）</span><span class="token function">getServerTime</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">serverTime</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//设置定时器</span>    <span class="token keyword">let</span> intervalTimer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 得到剩余时间</span>        <span class="token keyword">let</span> remainTime <span class="token operator">=</span> <span class="token function">getRemainTime</span><span class="token punctuation">(</span>endTime<span class="token punctuation">,</span> deviceTime<span class="token punctuation">,</span> serverTime<span class="token punctuation">)</span>        <span class="token comment">// 倒计时到两个小时内</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remainTime<span class="token punctuation">.</span>total <span class="token operator">&lt;=</span> <span class="token number">7200000</span> <span class="token operator">&amp;&amp;</span> remainTime<span class="token punctuation">.</span>total <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// do something</span>        <span class="token comment">//倒计时结束</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainTime<span class="token punctuation">.</span>total <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalTimer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// do something</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的的写法也可以做到准确倒计时，同时也比较简洁。不需要隔段时间再去同步一次服务端时间。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在写倒计时的时候遇到了一个坑这里记录一下。</p><p><strong>千万别在倒计时结束的时候请求接口</strong>。会让服务端瞬间 QPS 峰值达到非常高。</p><p><img src="https://img.alicdn.com/tfs/TB1LBzjOpXXXXcnXpXXXXXXXXXX-154-71.png"></p><p>如果在倒计时结束的时候要使用新的数据渲染页面，正确的做法是：</p><p>在倒计时结束前的一段时间里，先请求好数据，倒计时结束后，再渲染页面。</p><p>关于倒计时，如果你有什么更好的解决方案，欢迎评论交流。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04设置Pycharm桌面快捷键</title>
    <link href="https://running-dpf.github.io/2021/05/08/Ubuntu16-04-pycharm-icon-setting/"/>
    <id>https://running-dpf.github.io/2021/05/08/Ubuntu16-04-pycharm-icon-setting/</id>
    <published>2021-05-08T08:45:25.097Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu下所有的快捷方式都在："><a href="#Ubuntu下所有的快捷方式都在：" class="headerlink" title="Ubuntu下所有的快捷方式都在："></a>Ubuntu下所有的快捷方式都在：</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>applications<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>这里我将pycharm下载并解压到了/home/snakeson/developer文件夹下</p><p>这里的pycharm.sh是批处理执行文件，prcharm.png是快捷方式图标</p><span id="more"></span><h2 id="终端打开"><a href="#终端打开" class="headerlink" title="终端打开"></a>终端打开</h2><p>使用Ubuntu终端进行打开：<br>方法一（使用vim）：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">sudo vi  <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>applications<span class="token operator">/</span>pycharm<span class="token punctuation">.</span>desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二（使用gedit）：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">sudo gedit  <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>applications<span class="token operator">/</span>pycharm<span class="token punctuation">.</span>desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就会弹出一个新框：</p><h2 id="张贴"><a href="#张贴" class="headerlink" title="张贴"></a>张贴</h2><p>我们将下面的内容贴上去：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">[</span>Desktop Entry<span class="token punctuation">]</span>Type<span class="token operator">=</span>ApplicationName<span class="token operator">=</span>PycharmGenericName<span class="token operator">=</span>Pycharm3Comment<span class="token operator">=</span>Pycharm3<span class="token operator">:</span>The Python <span class="token constant">IDE</span>Exec<span class="token operator">=</span><span class="token string">"/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.sh"</span> <span class="token operator">%</span>fIcon<span class="token operator">=</span><span class="token operator">/</span>home<span class="token operator">/</span>snakeson<span class="token operator">/</span>developer<span class="token operator">/</span>pycharm<span class="token operator">-</span>community<span class="token operator">-</span><span class="token number">2017.2</span><span class="token number">.3</span><span class="token operator">/</span>bin<span class="token operator">/</span>pycharm<span class="token punctuation">.</span>pngTerminal<span class="token operator">=</span>pycharmCategories<span class="token operator">=</span>Pycharm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>注意一定要将Desktop Entry复制进去，也就是上面的全部都要复制进去，这里我们需要替换掉两个地方：<strong>Exec=”xx”<strong>和</strong>Icon=</strong>,这里要替换掉我们的pycharm解压的目录，当然了，我已经替换好了，如果你的目录跟我的目录不一样的话，你得把路径给换了，不管你是pycharm2017还是pycharm2016,，例如Comment什么的都不要改变，只变上面提到的两个路径就可以了。</p><h2 id="添加可执行权限"><a href="#添加可执行权限" class="headerlink" title="添加可执行权限"></a>添加可执行权限</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">sudo chmod <span class="token operator">+</span>x <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>applications<span class="token operator">/</span>pycharm<span class="token punctuation">.</span>desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="拷贝到桌面"><a href="#拷贝到桌面" class="headerlink" title="拷贝到桌面"></a>拷贝到桌面</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">将<span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>applications<span class="token operator">/</span>pycharm<span class="token punctuation">.</span>desktop文件拷贝到桌面，双击即可运行。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Ubuntu下所有的快捷方式都在：&quot;&gt;&lt;a href=&quot;#Ubuntu下所有的快捷方式都在：&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu下所有的快捷方式都在：&quot;&gt;&lt;/a&gt;Ubuntu下所有的快捷方式都在：&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-js&quot; data-language=&quot;js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;usr&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;share&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;applications&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;解压&quot;&gt;&lt;a href=&quot;#解压&quot; class=&quot;headerlink&quot; title=&quot;解压&quot;&gt;&lt;/a&gt;解压&lt;/h2&gt;&lt;p&gt;这里我将pycharm下载并解压到了/home/snakeson/developer文件夹下&lt;/p&gt;
&lt;p&gt;这里的pycharm.sh是批处理执行文件，prcharm.png是快捷方式图标&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://running-dpf.github.io/categories/python/"/>
    
    
    <category term="Ubuntu Python" scheme="https://running-dpf.github.io/tags/Ubuntu-Python/"/>
    
  </entry>
  
  <entry>
    <title>window下python3环境安装scrapy</title>
    <link href="https://running-dpf.github.io/2021/05/08/scrapy-setup-in-win/"/>
    <id>https://running-dpf.github.io/2021/05/08/scrapy-setup-in-win/</id>
    <published>2021-05-08T08:41:33.380Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>目录：</p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><blockquote><p>python3  3.6.4， win7 64位  </p></blockquote><span id="more"></span><h2 id="初次安装："><a href="#初次安装：" class="headerlink" title="初次安装："></a>初次安装：</h2><blockquote><p><code> pip install scrapy</code></p></blockquote><p>使用这个命令，在win7 64位是怎么也安装不上去的，因为这已经是第二次了，</p><p>当这个命令输出完后，会出现一系列的问题。当然了，不用怕，这不是需要解决问题的方法来了嘛。</p><p>可能出现需要下载版本对应的visual studio,但是也太大了，或也可以说下载慢。。。。。。但是，我们可以不用去进行下载，只要进行下面几个文件的安装就可以了。</p><h2 id="打开网站"><a href="#打开网站" class="headerlink" title="打开网站"></a>打开网站</h2><p>首先你打开这个网站（里面包含了各种编译好的库）：</p><blockquote><p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml">http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml</a></p></blockquote><h2 id="安装wheel"><a href="#安装wheel" class="headerlink" title="安装wheel"></a>安装wheel</h2><blockquote><p><code> pip install wheel</code></p></blockquote><p>安装成功的界面</p><p><img src="http://upload-images.jianshu.io/upload_images/2577413-93cab0d529ca1dba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wheel—success.png"></p><h2 id="安装-whl文件"><a href="#安装-whl文件" class="headerlink" title="安装.whl文件"></a>安装.whl文件</h2><p>这里需要安装三个.whl文件，而且是全名的安装，</p><p>以下三个文件：</p><p><img src="http://upload-images.jianshu.io/upload_images/2577413-eaf16a31171cd6ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".whl文件.png"></p><p>中途可能会出现<code>Failed to build XXXX </code> 或者是<code> twisted</code>等相关的内容</p><p>因为scrapy是基于twisted框架的，所以，twisted框架也需要进行安装</p><p>当上面三个文件安装好了：</p><p>再次运行：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">scrapy startproject pyjy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就完成了scrapy在win下python3下的安装</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;目录：&lt;/p&gt;
&lt;h2 id=&quot;环境：&quot;&gt;&lt;a href=&quot;#环境：&quot; class=&quot;headerlink&quot; title=&quot;环境：&quot;&gt;&lt;/a&gt;环境：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;python3  3.6.4， win7 64位  &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://running-dpf.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="scrapy" scheme="https://running-dpf.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>News_scrapy_redis 框架系统</title>
    <link href="https://running-dpf.github.io/2021/05/08/python-crawl-words/"/>
    <id>https://running-dpf.github.io/2021/05/08/python-crawl-words/</id>
    <published>2021-05-08T08:40:59.867Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文档针对爬虫系统设计目标中相应的场景给出技术方案</p><span id="more"></span><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>1、代码复用，功能模块化。可以支持上千个网站的数据爬取；</p><p>2、易扩展。爬虫框架易扩展，爬取规则、解析规则、入库规则易扩展，支持框架切换；</p><p>3、健壮性、可维护性。对数据爬取过程中的各种异常，例如：断网、反爬升级、爬“脏数据”等，需要实时的监控，以及给出准确的定位。异常处理以及降级措施需要完善；</p><p>4、后续扩展为分布式结构；</p><p>5、支持功能模块的易调整；</p><h2 id="框架使用说明"><a href="#框架使用说明" class="headerlink" title="框架使用说明"></a>框架使用说明</h2><p><strong>News_scrapy_redis4. <a href="https://github.com/xudailong/News_scrapy_redis.git">github地址</a></strong></p><ol><li><p><code>News_scrapy_redis</code> 基于<code>scrapy_redis</code>实现数据的增量爬取（含去重），支持分布式，支持异常日志等输出，功能模块化。</p></li><li><p>树结构：</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">├─<span class="token punctuation">.</span>idea├─Daily_crawler├─<span class="token constant">ETL</span>├─log├─News_scrapy│  ├─spiders│  │  └─__pycache__│  └─__pycache__├─News_simhash└─News_statistics<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>各模块说明：<blockquote><p>Daily_crawler：    </p></blockquote><ul><li><code>daily_crawler.cron crontab</code>的定时文件, 定时运行<code>start_crawl.sh</code>脚本</li><li><code>start_crawl.sh</code> 启动爬虫模块，并将每次爬取所花费的时间 写入 log/run_time.txt</li><li><code>push_urls.py</code> 每次在爬虫之前运行，清空调度队列，并将start_url push到调度队列中</li><li><code>news_crawl.sh</code> 执行爬虫模块（增量爬取）， 并自动进行相似文档去重，ETL, 存入mongodb</li></ul><blockquote><p>ETL:（暂时用不到）</p></blockquote><ul><li><code>/Model</code> 存放训练好的词典，语料，TF-IDF，LDA， word2vec模型</li><li><code>auto_embedding.py</code> 新闻语料的清洗，以及自动化生成新闻的标题和内容embedding</li><li><code>auto_embedding_simhash.py</code> 增加了自动化相似文档的去重</li><li><code>stop_words</code> 常用的中文停留词</li><li><code>train_step1</code> 训练LDA模型</li><li><code>train_step2</code> 训练LDA模型</li></ul><blockquote><p>log:</p></blockquote><ul><li><code>auto_embedding_simhash.log</code> 执行auto_embedding_simhash.py的日志文件</li><li><code>crawler.log</code> 执行scrapy-redis爬虫模块的日志文件</li><li><code>news_count.log</code> 执行news_statistics.py的日志文件</li><li><code>run_time.txt</code> 每次执行爬虫脚本的运行时间</li></ul><blockquote><p>News_data:</p></blockquote><ul><li>每个文件夹是抓每天从各个网站抓取到的新闻</li></ul><blockquote><p>News_scrapy:</p></blockquote><ul><li>基于scrapy-redis的爬虫模块，在scrapy的基础上修改得到</li><li>各大网站数据的爬取解析工作主要在该文件中进行</li></ul><blockquote><p>News_simhash（此处只需要进行title的去重）:</p></blockquote><ul><li>实现相似文档的去重</li><li>automatic_simhash.py 自动实现相似文档的去重（仅基于新闻内容）</li><li><code>near_duplicates.py</code> 对初始化的Simhash_index进行相似新闻内容的去重</li></ul><blockquote><p>News_statistics:</p></blockquote><ul><li><code>news_count.json</code> 每天从各个网站抓取的新闻数量</li><li><code>news_statistics.py</code> 统计新闻增量的脚本</li></ul></li></ol><h2 id="框架环境"><a href="#框架环境" class="headerlink" title="框架环境"></a>框架环境</h2><ol><li>Redis环境环境</li><li>scrapy框架环境</li><li>python3环境环境</li></ol><h2 id="框架完善"><a href="#框架完善" class="headerlink" title="框架完善"></a>框架完善</h2><ol><li>IP代理池</li><li>cookies池 </li><li>其他</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;该文档针对爬虫系统设计目标中相应的场景给出技术方案&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://running-dpf.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="scrapy" scheme="https://running-dpf.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记1-语法、对象、函数</title>
    <link href="https://running-dpf.github.io/2021/05/08/JavaScript-good-parts-note1/"/>
    <id>https://running-dpf.github.io/2021/05/08/JavaScript-good-parts-note1/</id>
    <published>2021-05-08T07:19:43.740Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。</p><p><img src="https://img3.doubanio.com/lpic/s3651235.jpg"></p><p>原书中第一章为精华，做了一些周边介绍，略去。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>这里说一下JavaScript的注释，一种是 <code>/* */</code> 包围的块注释，另一种是 <code>//</code> 开头的行注释。</p><p>因为块注释的字符可能是JavaScript中正则表达式字面量，因此不是很安全，如：</p><span id="more"></span><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*    var rm_a = /a*/</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符由一个字母开头，后面可选择性的加上一个或多个字母、数字或下划线。要避免保留字。</p><p>标识符被用于语句、变量、参数、属性名、运算符和标记。</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>可以存在指数部分，100和1e2完全相等</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token number">100</span> <span class="token operator">===</span> <span class="token number">1e2</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>isNaN</code>来检测<code>NaN</code>。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>当年 JavaScript 被创建的时候，Unicode 是16位字符集，因此 JavaScript 字符串是16位的。</p><p>用双引号或单引号包裹。</p><p>重点说一下转义字符<code>\</code></p><p>反斜杠后面可以跟<code>&quot;</code>, <code>&#39;</code>, <code>\</code>, <code>/</code>, <code>b</code> (backspace), <code>f</code> (formfeed), <code>n</code>, <code>r</code> (carriage return), <code>t</code>, <code>u1234</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token string">'A'</span> <span class="token operator">===</span> <span class="token string">'\u0041'</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>每个<code>&lt;script&gt;</code>标签的内容被一起抛到一个公共的全局名字空间中。</p><p><code>&#123;...&#125;</code>代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。</p><p>下列值当做假：</p><ul><li><code>false</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>&#39;&#39;</code></li><li><code>0</code></li><li><code>NaN</code></li></ul><p>其他所有值都当做真</p><p><code>for in</code>语句枚举对象的所有属性名（键名），使用<code>object.hasOwnProperty(variable)</code>来确定这个属性名是该对象成员，还是来自原型链。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span>myvar <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>myvar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>运算符优先级</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code> <code>[]</code> <code>()</code></td><td>提取属性与调用函数</td></tr><tr><td><code>delete</code> <code>new</code> <code>typeof</code> <code>+</code> <code>-</code> <code>!</code></td><td>一元运算符</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code></td><td></td></tr><tr><td><code>+</code> <code>-</code></td><td></td></tr><tr><td><code>&gt;=</code> <code>&lt;=</code> <code>&gt;</code> <code>&lt;</code></td><td></td></tr><tr><td><code>===</code> <code>!==</code></td><td></td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td>`</td><td></td></tr><tr><td><code>?:</code></td><td>三目</td></tr></tbody></table><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>对象字面量是一种可以方便地按指定规格创建新对象的表示法。</p><p>数组字面量是一种可以方便地按指定规格创建新数组的表示法。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数字面量定义了函数值。后续章节详谈。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是属性的容器，每一个属性都拥有名字和值。属性的名字可以是包含空字符串在内的任意字符串。属性的值可以是除<code>undefined</code>值之外的任何值。</p><p>JavaScript 包含一种原型链的特性，允许对象继承另一个对象的属性。正确地使用它能减少对象初始化时消耗的时间和内存。</p><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> empty_object <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> stooge <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    firstName<span class="token operator">:</span> <span class="token string">'Haoyang'</span><span class="token punctuation">,</span>    lastName<span class="token operator">:</span> <span class="token string">'Gao'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stooge<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Haoyang</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stooge<span class="token punctuation">[</span><span class="token string">'firstName'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Haoyang</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不存在的属性返回<code>undefined</code>。</p><p>使用<code>||</code>来填充默认值。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stooge<span class="token punctuation">.</span>firstName <span class="token operator">||</span> <span class="token string">'Joe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Haoyang</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stooge<span class="token punctuation">.</span>age <span class="token operator">||</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>直接使用赋值语句更新，若不存在这个属性，则作为扩充操作。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">stooge<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">'aaa'</span>stooge<span class="token punctuation">.</span>nickName <span class="token operator">=</span> <span class="token string">'peip'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stooge<span class="token punctuation">)</span> <span class="token comment">//Object &#123;firstName: "aaa", lastName: "Gao", nickName: "peip"&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>对象通过引用来传递他们永远不会被复制。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> stoogex<span class="token punctuation">.</span>hair <span class="token operator">=</span> <span class="token string">'black'</span>stooge<span class="token punctuation">.</span>hair <span class="token comment">//"black"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每一个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过字面量创建的对象都连接到<code>Object.prototype</code>，它是JavaScript中的标配对象。</p><p>可以使用<code>Object.create()</code>方法创建一个使用原对象作为其原型的新对象。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> anotherStooge <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>stooge<span class="token punctuation">)</span>anotherStooge<span class="token punctuation">.</span>firstName <span class="token comment">//"aaa"</span>anotherStooge<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">'bbb'</span>anotherStooge<span class="token punctuation">.</span>firstName <span class="token comment">//"bbb"</span>anotherStooge<span class="token punctuation">.</span>hair <span class="token comment">//"black"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新对象先查找自己的属性，若不存在则会向原型方向查找。</p><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4ieu7focqj207h05caaf.jpg"></p><p>当我们对某个对象作出改变时，不会触及该对象的原型。</p><p>原型关系是一种动态关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。</p><p>检查对象并确定对象有什么属性是很容易的事情，只要试着去检索该属性并验证取得的值。</p><p><code>typeof</code>用来确定对象属性的类型。</p><p><code>hasOwnProperty</code>，若对象拥有独有的属性，它将返回<code>true</code>。不会检查原型链。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用<code>for in</code>可以遍历一个对象中的所有属性名，包括原型链上的属性名。可以使用<code>hasOwnProperty</code>过滤原型链上的属性，使用<code>typeof</code>来排除函数。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> name <span class="token keyword">in</span> anotherStooge<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>anotherStooge<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> anotherStooge<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">'--->'</span> <span class="token operator">+</span> anotherStooge<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// firstName--->bbb</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性名是无序的，若想保持顺序应使用数组和<code>for</code>循环。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delete</code>可以用来删除对象的属性。若对象包含该属性，则会被移除。它不会触及原型链中的任何对象。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">anotherStooge<span class="token punctuation">.</span>firstName <span class="token comment">//"bbb"</span><span class="token keyword">delete</span> anotherStooge<span class="token punctuation">.</span>firstNameanotherStooge<span class="token punctuation">.</span>firstName <span class="token comment">//"aaa"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h3><p>JavaScript 可以随意的定义全局变量来容纳应用的所有资源。但这会削弱程序的灵活性，应避免使用全局变量。</p><p>最小化使用全局变量的方法之一是为应用只创建一个唯一的全局变量。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token constant">MYAPP</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token constant">MYAPP</span><span class="token punctuation">.</span>stooge <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span class="token constant">MYAPP</span><span class="token punctuation">.</span>flight <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一章将使用闭包来进行信息隐藏，是另一种有效减少全局污染的方法。</p><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>JavaScript 中的函数就是对象。函数对象连接到<code>Function.prototype</code>（该原型对象本身连接到<code>Object.prototype</code>）。每个函数对象在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。</p><p>函数对象在创建时也随配有一个<code>prototype</code>属性。它的值是一个拥有<code>constructor</code>属性且值即为该函数对象。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4lrei2b3pj208f06et95.jpg"></p><p>因为函数是对象，所以可以像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。函数也可以拥有方法。</p><p>函数的与众不同之处在于可以被调用。</p><h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>函数对象通过函数字面量来创建。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数字面量包含4部分，分别是：保留字 function、函数名、参数、花括号中的语句。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，还有两个附加参数：<code>this</code>和<code>arguments</code>。参数<code>this</code>在面向对象编程中非常重要，它的值取决于调用的模式。JavaScript中一共有4中调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式。</p><p>实参和形参个数不匹配时，不会有运行时错误。实参过多时，超出的实参被忽略。形参过多时，缺失的值被替换为<code>undefined</code>。</p><p>下面的内容也可以参考我以前的博文 <a href="http://gaohaoyang.github.io/2015/06/12/JavaScript-this/">JavaScript 中的 this</a></p><h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，<code>this</code>被绑定到该对象。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    value<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">inc</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token keyword">typeof</span> inc <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">?</span> inc <span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>myObject<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myObject<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">//1</span>myObject<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myObject<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">//4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p>当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。</p><p>此时<code>this</code>被绑定到全局对象。即时是内部函数也会将<code>this</code>绑定到全局对象。</p><p>可以在函数内创建一个属性并赋值为<code>this</code>来解决这个问题。如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span>myObject<span class="token punctuation">.</span><span class="token function-variable function">double</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">var</span> <span class="token function-variable function">helper</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        that<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">,</span> that<span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>myObject<span class="token punctuation">.</span><span class="token function">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myObject<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">//8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>JavaScript是一门基于原型继承的语言。对象可以直接从其他对象继承属性。该语言是无类型的。</p><p>如果在一个函数前面带上<code>new</code>来调用，那么背地里将会创建一个连接到该函数的<code>prototype</code>成员的新对象，同时<code>this</code>会被绑定到那个新对象上。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//创建构造器函数</span><span class="token keyword">var</span> <span class="token function-variable function">Quo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> string<span class="token punctuation">&#125;</span><span class="token comment">//给Que的所有实例提供一个公共方法</span><span class="token class-name">Quo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getStatus</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status<span class="token punctuation">&#125;</span><span class="token comment">//实例化</span><span class="token keyword">var</span> myQuo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Quo</span><span class="token punctuation">(</span><span class="token string">'confused'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myQuo<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//confused</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>书中不推荐这种形式的构造器函数，下一章有更好的解决方案。</p><h4 id="Apply-调用模式"><a href="#Apply-调用模式" class="headerlink" title="Apply 调用模式"></a>Apply 调用模式</h4><p><code>apply</code>方法让我们构建一个参数数组传递给调用函数。他也允许我们选择<code>this</code>的值。<code>apply</code>方法接受两个参数，第一个是要绑定给<code>this</code>的值，第二个是参数数组。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token comment">//7</span><span class="token keyword">var</span> statusObject <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    status<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> status <span class="token operator">=</span> <span class="token class-name">Quo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>statusObject<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token comment">//hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>当函数被调用时，会得到一个<code>arguments</code>数组。通过此参数可以访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形参的多余参数。这使得编写一个无须指定参数个数的函数成为可能。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> i<span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sum <span class="token operator">+=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//45</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因语言的设计错误，<code>arguments</code>并不是一个真正的数组。是一个“类似数组”的对象。有<code>length</code>属性，但没有任何数组的方法。</p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>函数执行时遇到关闭函数体的<code>&#125;</code>时结束。然后把控制权交还给调用该函数的程序。</p><p><code>return</code>可以使函数提前返回，不在执行余下的语句。</p><p>函数总是会返回一个值，若没有指定，则返回<code>undefined</code>。</p><p>若函数调用时在前面加上了<code>new</code>前缀，且返回值不是一个对象的时候，则返回<code>this</code>（该新对象）。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常是干扰程序的正常流畅的不寻常的事故。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">add2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a <span class="token operator">!==</span> <span class="token string">'number'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> b <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token punctuation">&#123;</span>            name<span class="token operator">:</span> <span class="token string">'TypeError'</span><span class="token punctuation">,</span>            message<span class="token operator">:</span> <span class="token string">'add needs numbers'</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add2</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4mprafcvhj20ml00xjrj.jpg"></p><p><code>throw</code>语句中断函数的执行。抛出一个<code>exception</code>对象，该对象包含一个用来识别异常类型的<code>name</code>属性和一个描述性的<code>message</code>属性。也可以自定义其他属性。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">try_it</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token function">add2</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">': '</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>message<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">try_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//TypeError: add needs numbers</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在<code>try</code>代码块内抛出一个异常，控制权就会跳转到它的<code>catch</code>语句中。</p><h3 id="扩充类型的功能"><a href="#扩充类型的功能" class="headerlink" title="扩充类型的功能"></a>扩充类型的功能</h3><p>JavaScript 允许给语言的基本类型扩充功能。通过<code>Object.prototype</code>添加方法，可以让该方法对所有对象都适用。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 先添加方法使得该方法对所有函数可用</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">method</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> func</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> func    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">&#125;</span><span class="token comment">//添加一个取整方法</span>Number<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">'integer'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">[</span><span class="token keyword">this</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">'ceil'</span> <span class="token operator">:</span> <span class="token string">'floor'</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">integer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//-3</span><span class="token comment">//添加 trim()</span>String<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">'trim'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\s+|\s+$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'  hello alibaba  '</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//hello alibaba</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript 原型继承是动态的，因此新的方法立刻被赋予到所有的对象实例上，即使对象实例是在方法被增加之前就创建好了。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数就是会直接或者间接地调用自身的一种函数。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">walkTheDom</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> func</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">func</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>    node <span class="token operator">=</span> node<span class="token punctuation">.</span>firstChild    <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> func<span class="token punctuation">)</span>        node <span class="token operator">=</span> node<span class="token punctuation">.</span>nextSibling    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">getElementsByAttribute</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">att<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token function">walkTheDom</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> actual <span class="token operator">=</span> node<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>att<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> actual <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>actual <span class="token operator">===</span> value <span class="token operator">||</span> <span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> results<span class="token punctuation">&#125;</span><span class="token comment">//在知乎主页上操作</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getElementsByAttribute</span><span class="token punctuation">(</span><span class="token string">'data-za-module'</span><span class="token punctuation">,</span> <span class="token string">'AnswerItem'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//得到下列数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域控制着变量与参数的可见性及生命周期。它减少了名称冲突，并提供了自动内存管理。</p><p>无块级作用域。</p><p>有函数作用域。</p><p>建议在函数体的顶部声明函数中可能用到的所有变量。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>作用域的好处是内部函数可以访问定义他们的外部函数的参数和变量（除了<code>this</code>和<code>arguments</code>）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">quo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        <span class="token function-variable function">get_status</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> status        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> myQuo <span class="token operator">=</span> <span class="token function">quo</span><span class="token punctuation">(</span><span class="token string">'amazed'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myQuo<span class="token punctuation">.</span><span class="token function">get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//amazed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>狭义的说，返回的那个对象即闭包，它里面的方法可以访问它被创建时所处的上下文环境。</p><p>避免在循环中创建函数，容易引起混淆。可以现在循环之外创建一个辅助函数，让辅助函数在返回一个绑定了当前<code>i</code>值的函数，这样就不会导致混淆了。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>将一个函数作为参数，一旦接收到响应，再调用这个函数。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>可以用函数和闭包构造模块。</p><p>模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可访问到的地方。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> numberCal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> <span class="token function-variable function">half</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> n <span class="token operator">/</span> <span class="token number">2</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> <span class="token function-variable function">double</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token number">2</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> <span class="token function-variable function">tribble</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token number">3</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        half<span class="token operator">:</span> half<span class="token punctuation">,</span>        double<span class="token operator">:</span> double<span class="token punctuation">,</span>        tribble<span class="token operator">:</span> tribble    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numberCal<span class="token punctuation">.</span><span class="token function">half</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//2.5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numberCal<span class="token punctuation">.</span><span class="token function">half</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numberCal<span class="token punctuation">.</span><span class="token function">double</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//14</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numberCal<span class="token punctuation">.</span><span class="token function">tribble</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>如果让方法返回<code>this</code>而不是默认的<code>undefined</code>，就可以启用级联，即连续调用。</p><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。</p><p>详情见以前的博文 <a href="http://gaohaoyang.github.io/2015/06/11/JavaScript-function/#bind--currying">JavaScript 函数 -bind 与 currying</a>。</p><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/lpic/s3651235.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;原书中第一章为精华，做了一些周边介绍，略去。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;h3 id=&quot;空白&quot;&gt;&lt;a href=&quot;#空白&quot; class=&quot;headerlink&quot; title=&quot;空白&quot;&gt;&lt;/a&gt;空白&lt;/h3&gt;&lt;p&gt;这里说一下JavaScript的注释，一种是 &lt;code&gt;/* */&lt;/code&gt; 包围的块注释，另一种是 &lt;code&gt;//&lt;/code&gt; 开头的行注释。&lt;/p&gt;
&lt;p&gt;因为块注释的字符可能是JavaScript中正则表达式字面量，因此不是很安全，如：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/categories/JavaScript/"/>
    
    
    <category term="对象 函数 this 闭包 面向对象 作用域" scheme="https://running-dpf.github.io/tags/%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0-this-%E9%97%AD%E5%8C%85-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记2-继承、数组、正则表达式</title>
    <link href="https://running-dpf.github.io/2021/05/08/JavaScript-good-parts-note2/"/>
    <id>https://running-dpf.github.io/2021/05/08/JavaScript-good-parts-note2/</id>
    <published>2021-05-08T07:19:15.229Z</published>
    <updated>2021-05-20T05:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的两大好处：代码重用，引入一套类型系统的规范。</p><span id="more"></span><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>JavaScript 通过构造器函数产生对象。</p><p>构造器调用模式，即用<code>new</code>前缀去调用一个函数。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">Mammal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">&#125;</span><span class="token class-name">Mammal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span><span class="token class-name">Mammal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">says</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>saying <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> myMammal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mammal</span><span class="token punctuation">(</span><span class="token string">'Herb'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMammal<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//Herb</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>书中不推荐这样的写法。有很多风险。若忘记添加<code>new</code>前缀，<code>this</code>无法绑定到新的对象上。而是绑定到了全局对象上，破坏了全局变量环境。</p><h3 id="对象说明符"><a href="#对象说明符" class="headerlink" title="对象说明符"></a>对象说明符</h3><p>上一节中的构造器可能要接受一大串参数。我们可以这样写：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token function">Maker</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    first<span class="token operator">:</span> f<span class="token punctuation">,</span>    middle<span class="token operator">:</span> m<span class="token punctuation">,</span>    last<span class="token operator">:</span> l<span class="token punctuation">,</span>    state<span class="token operator">:</span> s<span class="token punctuation">,</span>    city<span class="token operator">:</span> c<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将JSON对象传递给构造器，而它返回一个构造完全的对象。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在一个纯粹的原型模式中，我们将摒弃类，转而专注于对象。一个新对象可以继承一个就对象的属性。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> myMammal <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'MM'</span><span class="token punctuation">,</span>    <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function-variable function">says</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>saying <span class="token operator">||</span> <span class="token string">''</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> myCat <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>myMammal<span class="token punctuation">)</span>myCat<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Kitty'</span>myCat<span class="token punctuation">.</span>saying <span class="token operator">=</span> <span class="token string">'meow'</span>myCat<span class="token punctuation">.</span><span class="token function-variable function">run</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'Kitty is running'</span><span class="token punctuation">&#125;</span>myCat<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>says <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>says<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一种差异化继承。</p><h3 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h3><p>前文看到的继承模式没法保护隐私。对象的所有属性都是可见的。无法得到私有变量和私有函数。为了解决这一问题，我们有模块模式。</p><p>构造一个生成对象的函数需要4步骤：</p><ol><li>创建一个新对象。</li><li>有选择的定义私有变量和方法。</li><li>给这个新对象扩充方法。</li><li>返回那个新对象。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">mammal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">spec</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    that<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> spec<span class="token punctuation">.</span>name    <span class="token punctuation">&#125;</span>    that<span class="token punctuation">.</span><span class="token function-variable function">says</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> spec<span class="token punctuation">.</span>saying <span class="token operator">||</span> <span class="token string">''</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> that<span class="token punctuation">&#125;</span><span class="token keyword">var</span> myMammal <span class="token operator">=</span> <span class="token function">mammal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'Herb'</span><span class="token punctuation">,</span>    saying<span class="token operator">:</span> <span class="token string">'Cheers!'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMammal<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//Herb</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMammal<span class="token punctuation">.</span><span class="token function">says</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//Cheers!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以参考上一篇文章，<a href="http://gaohaoyang.github.io/2016/06/07/JavaScript-good-parts-note1/#section-34">JavaScript 语言精粹笔记1-语法、对象、函数 之模块部分</a>。</p><h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>这一部分看的不是特别懂，我想等我学完ES2015中的类和模块部分后再看看吧。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>一个数组字面量是在一对方括号中包围零个或多个用逗号分隔的值的表达式。</p><p>再大多数语言中，一个数组的多有元素都要求是相同的类型。JavaScript 允许数组包含任意混合类型的值。</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>JavaScript 数组的<code>length</code>属性是没有上界的。如果用大于或等于当前<code>length</code>的数字作为下标来存储一个元素，那么<code>length</code>值会被增大以容纳新元素，不会发生数组越界错误。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>数组也是对象，可以用<code>delete</code>来删除元素</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">,</span> <span class="token string">'wu'</span><span class="token punctuation">]</span><span class="token keyword">delete</span> numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>splice</code>方法，进行删除和修改操作。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">numbers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//two</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用常规<code>for</code>循环即可，可以保证数组的顺序。</p><h3 id="容易混淆的地方"><a href="#容易混淆的地方" class="headerlink" title="容易混淆的地方"></a>容易混淆的地方</h3><p>当属性名是小而连续的整数时，应该使用数组，否则使用对象。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//object</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回数组的类型是<code>object</code>，没有任何意义。</p><p>判断数组类型的方法</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ECMAScript 5.1 (ECMA-262) 和 ECMAScript 2015 (6th Edition, ECMA-262) 标准中的方法。</p><p>或者下面这个方法。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">is_array</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">is_array</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>数组的方法被存储在<code>Array.prototype</code>中的函数。</p><p>数组是对象，因此<code>Array.prototype</code>也是可扩充的。</p><h3 id="指定初始值"><a href="#指定初始值" class="headerlink" title="指定初始值"></a>指定初始值</h3><p>JavaScript 的数组不会预制值。</p><p>JavaScript 没有多维数组，单项大多数类 C 语言一样，支持元素为数组的数组。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> matrix <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>关于正则表达式，以前的博文写的比较多了，详情见：</p><p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-10">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分1</a></p><p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-12">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分2</a></p><p><a href="http://gaohaoyang.github.io/2016/05/06/regular-expression-group/">浅谈正则表达式中的分组和引用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;继承的两大好处：代码重用，引入一套类型系统的规范。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://running-dpf.github.io/categories/JavaScript/"/>
    
    
    <category term="继承 对象 原型 Array 正则" scheme="https://running-dpf.github.io/tags/%E7%BB%A7%E6%89%BF-%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B-Array-%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
</feed>
