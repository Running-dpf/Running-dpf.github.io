<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jekyll 搭建静态博客</title>
    <url>/2015/02/15/2015/02/reate-my-blog-with-jekyll/</url>
    <content><![CDATA[<p>一直以来都想搭建一个自己的博客，但是近半年做项目太忙，再加上教研室的网络很坑爹，所以也一直没顾得上。之前用过 WordPress 托管在免费的京东云擎上，但是速度太慢。在知乎上看到一些相关的内容，于是选择了在github上用jekyll搭建博客。</p>
<span id="more"></span>




<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>在jekyll的官网上 <a href="http://jekyllrb.com/">http://jekyllrb.com/</a> 其实已经说得比较明白了，我在这里还是简单的说一下吧。我用的是Windows系统。<br>主要环节有：安装Ruby，安装RubyGems，安装jekyll，安装代码高亮插件，安装node.js</p>
<h3 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h3><p>ruby官网下载安装：<a href="https://www.ruby-lang.org/en/downloads/">https://www.ruby-lang.org/en/downloads/</a></p>
<p>安装完成后配置环境变量</p>
<p>在命令提示符中，得到ruby版本号，如下图，即安装成功</p>
<p><img src="ww4.sinaimg.cn/large/7011d6cfjw1f2ue0e393vj20cu00t748.jpg"></p>
<h3 id="安装RubyGems"><a href="#安装RubyGems" class="headerlink" title="安装RubyGems"></a>安装RubyGems</h3><p>官网下载 <a href="http://rubygems.org/pages/download">http://rubygems.org/pages/download</a> rubygems-2.4.5.zip   </p>
<p>cd到RubyGems目录   </p>
<p><img src="ww1.sinaimg.cn/large/7011d6cfjw1f2ue1l2yscj20gk02amxj.jpg"></p>
<p>执行安装   </p>
<p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f2ue1w8eqnj20bx00hglg.jpg">  </p>
<h3 id="用RubyGems安装Jekyll"><a href="#用RubyGems安装Jekyll" class="headerlink" title="用RubyGems安装Jekyll"></a>用RubyGems安装Jekyll</h3><p>执行下面的语句安装   </p>
<p><img src="http://ww4.sinaimg.cn/large/7011d6cfjw1f2ue2g2p3uj207x00ft8j.jpg"></p>
<p>安装结束画面   </p>
<p><img src="http://ww4.sinaimg.cn/large/7011d6cfjw1f2ue32drwhj20hv09xq5m.jpg"></p>
<p>至此jekyll就已经安装完毕了，后续就是个性化的自己设定了。</p>
<h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><p>在d盘新建一个工作区jekyllWorkspace</p>
<p>cd到jekyllWorkspace   </p>
<p>执行jekyll new name创建新的工作区   </p>
<p><img src="http://ww3.sinaimg.cn/large/7011d6cfjw1f2ue3lt31nj20cj02nt8u.jpg"></p>
<p>文件结构如下：   </p>
<p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f2ue3ujsybj20ek06wabh.jpg"></p>
<p>cd到博客文件夹，开启服务器   </p>
<p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f2ue47y9lgj20ao00f0sl.jpg"></p>
<p>watch为了检测文件夹内的变化，即修改后不需要重新启动jekyll</p>
<p>我的环境下启动报错(你的可能没有)，再安装yajl-ruby和rouge  </p>
<p><img src="http://ww4.sinaimg.cn/large/7011d6cfjw1f2ue4nelnxj20dd077q49.jpg"></p>
<p>再次启动服务器成功</p>
<p><img src="http://ww4.sinaimg.cn/large/7011d6cfjw1f2ue4v42koj20g505bdgy.jpg"></p>
<p>访问 <a href="http://localhost:4000/">http://localhost:4000/</a>   </p>
<p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f2ue56ckwoj20je0eumz3.jpg"></p>
<p>详细文章页面   </p>
<p><img src="http://ww2.sinaimg.cn/large/7011d6cfjw1f2ue5f3j9cj20je0gyq7a.jpg"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul>
<li> 整个安装过程参考了jekyll官网，注意jekyll还有一个简体中文官网，不过比较坑（我就被坑了），有些内容没有翻译过来，有可能会走弯路，建议如果想看中文的相关资料，也要中英对照着阅读。<a href="http://jekyllcn.com/">jekyll中文网 http://jekyllcn.com</a>, <a href="http://jekyllrb.com/">jekyll英文网 http://jekyllrb.com</a></li>
<li> jekyll中的css是用sass写的，当然直接在<code>_sass/_layout.scss</code>中添加css也是可以的。</li>
<li> 本文是用Markdown格式来写的，相关语法可参考： <a href="http://wowubuntu.com/markdown/">Markdown 语法说明 (简体中文版) http://wowubuntu.com/markdown/</a>  </li>
<li> 按照本文的说明搭建完博客后，用<code>github Pages</code>托管就可以看到了。注意，在github上面好像不支持rouge，所以要push到github上时，我将配置文件_config.yml中的代码高亮改变为<code>highlighter: pygments</code>就可以了</li>
<li> 博客默认是没有评论系统的，本文的评论系统使用了多说，详细安装办法可访问<a href="http://duoshuo.com/">多说官网 http://duoshuo.com/</a>，当然也可以使用<a href="http://changyan.sohu.com/">搜狐畅言 http://changyan.sohu.com/</a>作为评论系统。</li>
<li> 也可以绑定自己的域名，如果没有域名，可以在<a href="http://www.godaddy.com/">godaddy http://www.godaddy.com/</a>上将域名放入购物车等待降价，买之。</li>
<li> 祝各位新年快乐！</li>
</ul>
<hr>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><h3 id="hitimes-hitimes-LoadError"><a href="#hitimes-hitimes-LoadError" class="headerlink" title="hitimes/hitimes (LoadError)"></a><code>hitimes/hitimes (LoadError)</code></h3><p><strong>错误代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;Ruby22&#x2F;lib&#x2F;ruby&#x2F;2.2.0&#x2F;rubygems&#x2F;core_ext&#x2F;kernel_require.rb:54:in &#96;require&#39;: cannot load such file -- hitimes&#x2F;hitimes (LoadError)</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>在stackoverflow上又一个很好的解决方法。<a href="http://stackoverflow.com/questions/28985481/hitimes-require-error-when-running-jekyll-serve-on-windows-8-1">hitimes require error when running jekyll serve on windows 8.1</a> 虽然上面的题主问的是 win 8.1 系统下的情况，但是同样适用于 win7。下面我简单翻译一下错误原因和解决方法。</p>
<blockquote>
<p>可能是 Ruby 2.2 和 hitimes-1.2.2-x86-mingw32 中有一些 ABI 变化，少了一些相关的类库。</p>
<p>所以卸载 hitimes 并通过 <code>--platform ruby</code> 重装即可。代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem uni hitimes</span><br><span class="line">**Remove ALL versions**</span><br><span class="line">gem ins hitimes -v 1.2.1 --platform ruby</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后将自动重新编译 hitimes 并适用于 Ruby 2.2</p>
</blockquote>
<p>下面是我自己的卸载和安装过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\GitWorkSpace\gaohaoyang.github.io&gt;gem uni hitimes</span><br><span class="line"></span><br><span class="line">You have requested to uninstall the gem:</span><br><span class="line">        hitimes-1.2.2-x86-mingw32</span><br><span class="line"></span><br><span class="line">timers-4.0.1 depends on hitimes (&gt;&#x3D; 0)</span><br><span class="line">If you remove this gem, these dependencies will not be met.</span><br><span class="line">Continue with Uninstall? [yN]  y</span><br><span class="line">Successfully uninstalled hitimes-1.2.2-x86-mingw32</span><br><span class="line"></span><br><span class="line">E:\GitWorkSpace\gaohaoyang.github.io&gt;gem ins hitimes -v 1.2.1 --platform ruby</span><br><span class="line">Fetching: hitimes-1.2.1.gem (100%)</span><br><span class="line">Temporarily enhancing PATH to include DevKit...</span><br><span class="line">Building native extensions.  This could take a while...</span><br><span class="line">Successfully installed hitimes-1.2.1</span><br><span class="line">Parsing documentation for hitimes-1.2.1</span><br><span class="line">Installing ri documentation for hitimes-1.2.1</span><br><span class="line">Done installing documentation for hitimes after 1 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure>


<p>关于，<a href="https://rubygems.org/gems/hitimes/versions/1.2.2">hitimes</a> 是一个快速的高效的定时器解决方案库，详情可以去官网查看。</p>
]]></content>
      <categories>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>代码校验工具 SublimeLinter 的安装与使用</title>
    <url>/2015/03/26/2015/03/sublimeLinter/</url>
    <content><![CDATA[<p>本文我将讲述一下 SublimeLinter 的安装过程。其组件 jshint 的安装与使用。其组件 csslint 的安装与使用。我将基于 <a href="http://sublimetext.com/3">Sublime Text 3</a> 来安装。使用 Sublime Text 2 的用户阅读本文是没有帮助的。</p>
<span id="more"></span>
<p>SublimeLinter 是 Sublime 的插件，它的作用是检查代码语法是否有错误，并提示。习惯了 IDE 下写代码的人一定需要一款在 Sublime 上类似的语法检查工具。下面我们开始。   </p>
<h2 id="安装-SublimeLinter"><a href="#安装-SublimeLinter" class="headerlink" title="安装 SublimeLinter"></a>安装 SublimeLinter</h2><p>如同其他插件一样使用 Package Control 来安装。   </p>
<ol>
<li>按下 <code>Ctrl+Shift+p</code> 进入 Command Palette   </li>
<li>输入<code>install</code>进入 Package Control: Install Package   </li>
<li>输入<code>SublimeLinter</code>。进行安装.   </li>
</ol>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-sublimeLinter.jpg" alt="SublimeLinter">   </p>
<p>安装完成后可以看到这样一段话：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to SublimeLinter, a linter framework for Sublime Text 3.</span><br><span class="line"></span><br><span class="line">                  * * * IMPORTANT! * * *</span><br><span class="line"></span><br><span class="line">         SublimeLinter 3 is NOT a drop-in replacement for</span><br><span class="line">        earlier versions.</span><br><span class="line"></span><br><span class="line">         Linters *NOT* included with SublimeLinter 3,</span><br><span class="line">         they must be installed separately.</span><br><span class="line"></span><br><span class="line">         The settings are different.</span><br><span class="line"></span><br><span class="line">                 * * * READ THE DOCS! * * *</span><br><span class="line"></span><br><span class="line"> Otherwise you will never know how to install linters, nor will</span><br><span class="line"> you know about all of the great new features in SublimeLinter 3.</span><br><span class="line"></span><br><span class="line"> For complete documentation on how to install and use SublimeLinter,</span><br><span class="line"> please see:</span><br><span class="line"></span><br><span class="line"> http:&#x2F;&#x2F;www.sublimelinter.com</span><br></pre></td></tr></table></figure>

<p>可以看到具体的 Linters 组件<strong>不</strong>被包含在 SublimeLinter 3 中，所以我们要额外独立安装组件。<br>可以针对不同的语言安装不同的组件。   </p>
<h2 id="JavaScript-语法检查"><a href="#JavaScript-语法检查" class="headerlink" title="JavaScript 语法检查"></a>JavaScript 语法检查</h2><p>SublimeLinter-jshint 是基于 nodeJS 下的 jshint 的插件，实际上 SublimeLinter-jshint 调用了 nodeJS 中 jshint 的接口来进行语法检查的。   </p>
<hr>
<h3 id="安装-SublimeLinter-jshint"><a href="#安装-SublimeLinter-jshint" class="headerlink" title="安装 SublimeLinter-jshint"></a>安装 SublimeLinter-jshint</h3><p>为了让 JavaScript 代码有语法检查，我们安装 SublimeLinter-jshint<br>同样的方法，我们安装 SublimeLinter-jshint    </p>
<ol>
<li>按下 <code>Ctrl+Shift+p</code> 进入 Command Palette   </li>
<li>输入<code>install</code>进入 Package Control: Install Package   </li>
<li>输入<code>SublimeLinter-jshint</code>。进行安装.   </li>
</ol>
<p>如下图   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-jshint.jpg" alt="SublimeLinter-jshint">   </p>
<p>安装完成后我们可以看到下面的一段话   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SublimeLinter-jshint</span><br><span class="line">  -------------------------------</span><br><span class="line">  This linter plugin for SublimeLinter provides an interface to jshint.</span><br><span class="line"></span><br><span class="line">  ** IMPORTANT! **</span><br><span class="line"></span><br><span class="line">  Before this plugin will activate, you *must*</span><br><span class="line">  follow the installation instructions here:</span><br><span class="line"></span><br><span class="line">  https:&#x2F;&#x2F;github.com&#x2F;SublimeLinter&#x2F;SublimeLinter-jshint</span><br></pre></td></tr></table></figure>

<h3 id="安装-nodeJS-和-jshint"><a href="#安装-nodeJS-和-jshint" class="headerlink" title="安装 nodeJS 和 jshint"></a>安装 nodeJS 和 jshint</h3><p>在插件开始工作之前，我们必须再看一下上述插件的<a href="https://github.com/SublimeLinter/SublimeLinter-jshint">安装说明</a><br>通过 <a href="https://github.com/SublimeLinter/SublimeLinter-jshint">SublimeLinter-jshint 的说明</a> 我们可以看到，这个组件依赖于 nodeJS 下的 jshint，所以我们安装 nodeJS 环境和 nodeJS 下的 jshint。   </p>
<ol>
<li>安装 <a href="https://nodejs.org/">Node.js</a>   </li>
<li>通过 npm 安装<code>jshint</code>   </li>
</ol>
<p>在命令行下输入如下代码，完成安装   </p>
<pre><code>npm install -g jshint
</code></pre>
<p>安装完成后命令行中出现如下的信息   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\npm\jshint -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\jshint\bin\jshint</span><br><span class="line">jshint@2.6.3 C:\Users\Administrator\AppData\Roaming\npm\node_modules\jshint</span><br><span class="line">├── strip-json-comments@1.0.2</span><br><span class="line">├── underscore@1.6.0</span><br><span class="line">├── exit@0.1.2</span><br><span class="line">├── shelljs@0.3.0</span><br><span class="line">├── console-browserify@1.1.0 (date-now@0.1.4)</span><br><span class="line">├── htmlparser2@3.8.2 (domelementtype@1.3.0, entities@1.0.0, domhandler@2.3.0, readable-stream@1.1.13, domutils@1.5.1)</span><br><span class="line">├── minimatch@1.0.0 (sigmund@1.0.0, lru-cache@2.5.0)</span><br><span class="line">└── cli@0.6.6 (glob@3.2.11)</span><br></pre></td></tr></table></figure>

<p>可以查看 jshint 版本，已确认安装完成。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jshint -v</span><br><span class="line">jshint v2.6.3</span><br></pre></td></tr></table></figure>

<p>现在，恭喜你，我们使用 Sublime 编辑 JavaScript 文件，就会有语法检查了！   </p>
<p>在编辑过程中，会有如下提示   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-jshint-test.jpg" alt="SublimeLinter-jshint-test"></p>
<p>点击提示点后，Sublime 状态栏也会有相应的说明   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-jshint-test2.jpg" alt="SublimeLinter-jshint-test2"></p>
<h2 id="css-语法检查"><a href="#css-语法检查" class="headerlink" title="css 语法检查"></a>css 语法检查</h2><p>与 jshint 同理，SublimeLinter-csslint 也是基于 nodeJS 下的 csslint 的插件，实际上 SublimeLinter-csslint 调用了 nodeJS 中 csslint 的接口来进行语法检查的。   </p>
<hr>
<h3 id="安装-SublimeLinter-csslint"><a href="#安装-SublimeLinter-csslint" class="headerlink" title="安装 SublimeLinter-csslint"></a>安装 SublimeLinter-csslint</h3><p>同样的方法。   </p>
<ol>
<li>按下 <code>Ctrl+Shift+p</code> 进入 Command Palette   </li>
<li>输入<code>install</code>进入 Package Control: Install Package   </li>
<li>输入<code>SublimeLinter-csslint</code>。进行安装.   </li>
</ol>
<p>如下图   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-csslint.jpg" alt="SublimeLinter-csslint">   </p>
<p>安装完成后我们可以看到下面的一段话   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SublimeLinter-csslint</span><br><span class="line">-------------------------------</span><br><span class="line">This linter plugin for SublimeLinter provides an interface to csslint.</span><br><span class="line"></span><br><span class="line">** IMPORTANT! **</span><br><span class="line"></span><br><span class="line">Before this plugin will activate, you *must*</span><br><span class="line">follow the installation instructions here:</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SublimeLinter&#x2F;SublimeLinter-csslint</span><br></pre></td></tr></table></figure>

<p>在使用插件之前，必须遵循上述网址中的<a href="https://github.com/SublimeLinter/SublimeLinter-csslint">安装说明</a>   </p>
<h3 id="在-nodeJS-下安装-csslint"><a href="#在-nodeJS-下安装-csslint" class="headerlink" title="在 nodeJS 下安装 csslint"></a>在 nodeJS 下安装 csslint</h3><p>进入上述的 GitHub 地址，csslint 的说明页。我们知道了和 jshint 一样，csslint 也是基于 nodeJS 下的 csslint 来使用的。   </p>
<p>这里安装 nodeJS 过程省略。<br>只需用 npm 安装 csslint 即可。   </p>
<p>在命令行中输入     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g csslint   </span><br></pre></td></tr></table></figure>

<p>安装完成后命令行中出现如下的信息     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\npm\csslint -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\csslint\cli.js</span><br><span class="line">csslint@0.10.0 C:\Users\Administrator\AppData\Roaming\npm\node_modules\csslint</span><br><span class="line">└── parserlib@0.2.5</span><br></pre></td></tr></table></figure>

<p>可以查看 csslint 版本，已确认安装完成。   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;csslint --version</span><br><span class="line">v0.10.0</span><br></pre></td></tr></table></figure>

<p>现在，恭喜你，我们使用 Sublime 编辑 css 文件，就会有语法检查了！     </p>
<p>在编辑过程中，会有如下提示   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-csslint-test.jpg" alt="SublimeLinter-csslint-test"></p>
<p>点击提示点后，Sublime 状态栏也会有相应的说明   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-csslint-test2.jpg" alt="SublimeLinter-csslint-test2"></p>
]]></content>
      <categories>
        <category>Sublime</category>
      </categories>
      <tags>
        <tag>Sublime jshint csslint</tag>
      </tags>
  </entry>
  <entry>
    <title>对这个 jekyll 博客主题的改版和重构</title>
    <url>/2016/03/12/2016/03/jekyll-theme-version-2.0/</url>
    <content><![CDATA[<p>本文主要说明对这个博客主题的改版和代码重构的过程。这个简洁高雅的博客主题受到了很多朋友的喜欢。在写第一版界面时，我对前端并不是很熟悉，对<code>Jekyll</code>也不熟悉。现在距离当时也一年了，对自己当时写的代码也不太满意了，同时<code>Jekyll</code>如今也已经升级了，目前最新版为3.1.2。因此我在临近毕业尚未入职前做一下博客主题的代码重构和改版吧。</p>
<span id="more"></span>
<p>主要想做这些事情有：添加归档，添加标签，添加分类页面，主页显示文章摘要，代码去除 jQuery 和 BootStrap，优化移动端显示，将所有变量写入配置文件<code>_config.yml</code>中等。再优化一些细节吧。希望更多人会喜欢。</p>
<h2 id="改版重构说明"><a href="#改版重构说明" class="headerlink" title="改版重构说明"></a>改版重构说明</h2><ul>
<li><p><strong>使用 GitHub 风格的代码块 Markdown 写法 (Fenced code blocks)。</strong></p>
<p>  即 GFM(github flavored markdown) 的方式。</p>
<p>  Jekyll 已经升级至 3.1.2（2016-03），其中有一些新的要注意的地方，比如官网上说使用了 <code>Rouge</code> 去做代码高亮而不是默认的 <code>Pygments</code>，因为 <code>Jekyll</code> 本身是基于 Ruby 的，因此我看到官方说希望不再使用基于 Python 的 <code>Pygments</code> 了，而是都使用基于 Ruby 的代码。详情见官网升级说明 <a href="https://jekyllrb.com/docs/upgrading/2-to-3/#syntax-highlighter-changed">syntax-highlighter-changed</a>。</p>
</li>
<li><p><strong>首页中添加摘要</strong></p>
<p>  摘要可以在每一篇 md 文件头中使用 excerpt 属性写出来。也可以在正文中，4个换行符来分割，这个设置见配置文件<code>_config.yml</code>。</p>
</li>
<li><p><strong>添加归档</strong></p>
<p>  上一版中没有归档，现在专门做了一个归档页面，当文章很多时方便根据年份快速查阅。</p>
</li>
<li><p><strong>添加标签</strong></p>
<p>  标签还是很有必要添加的，上一版中也没有这个功能。现在也可以根据标签查找文章了。同时标签还有一个重要的作用是，用来获取相似文章的。</p>
</li>
<li><p><strong>添加分类页</strong></p>
<p>  之前的分类就是在首页中直接完成的，现在和标签和归档类似，我将分类单独制作为一页，方便查阅。</p>
</li>
<li><p><strong>去掉 jQuery 和 BootStrap</strong></p>
<p>  我觉得太重了，没必要使用这两个库，使用原生 JavaScript 和 CSS就可以做到一样的效果，代码量大大减轻，载入速度略有提高。</p>
</li>
<li><p><strong>重写了demo页的瀑布流布局</strong></p>
<p>  改变数据写死的方式，将数据用 json 格式录入，由 JavaScript 拼接为 HTML 代码。同时，使用 <a href="http://masonry.desandro.com/">Masonry</a>，重写了瀑布流布局。</p>
</li>
<li><p><strong>简化评论配置，支持 多说 和 disqus</strong></p>
<p>  在<code>_config.yml</code>中评论配置直接添加自己的<code>short_name</code>，评论就能正常使用了。</p>
</li>
</ul>
<p>下面列举一些可能遇到的问题，至少我是遇到了：</p>
<h2 id="RubyGems-无法访问，SSL-证书问题"><a href="#RubyGems-无法访问，SSL-证书问题" class="headerlink" title="RubyGems 无法访问，SSL 证书问题"></a>RubyGems 无法访问，SSL 证书问题</h2><p>以前我使用的是 RubyGems 的淘宝镜像<a href="https://ruby.taobao.org/">https://ruby.taobao.org/</a>。现在这个镜像已经不再维护了，作者 <a href="https://ruby-china.org/huacnlee">huacnlee (李华顺)</a> 转到 <a href="https://ruby-china.org/">Ruby China</a> 中继续维护了，详情见 <a href="https://gems.ruby-china.org/">RubyGems 镜像- Ruby China</a>。</p>
<h3 id="错误呈现"><a href="#错误呈现" class="headerlink" title="错误呈现"></a>错误呈现</h3><p>在执行任何<code>gem</code>命令的时候出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)</span><br><span class="line">    SSL_connect returned&#x3D;1 errno&#x3D;0 state&#x3D;SSLv3 read server certificate B: certificate verify failed (https:&#x2F;&#x2F;gems.ruby-china.org&#x2F;specs.4.8.gz)</span><br></pre></td></tr></table></figure>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>根据 <a href="https://gems.ruby-china.org/">https://gems.ruby-china.org/</a> 页面最下方提供的 GitHub Issue 地址。</p>
<p>可以进入这个 issue：<a href="https://github.com/ruby-china/rubygems-mirror/issues/3">https://github.com/ruby-china/rubygems-mirror/issues/3</a></p>
<p>其中 sanlengjingvv 给出了一个链接地址 <a href="https://gist.github.com/fnichol/867550">https://gist.github.com/fnichol/867550</a> 里面提供了方法。我就是采用这里面的方法解决的。</p>
<p>我使用的是 <a href="https://gist.github.com/fnichol/867550#the-manual-way-boring">The Manual Way</a>，因为 <a href="https://gist.github.com/fnichol/867550#the-ruby-way-fun">The Ruby Way</a> 我没有成功，不知道什么原因，有兴趣的朋友可以试试。下面说说我的具体操作吧。</p>
<p>首先从 <a href="https://curl.haxx.se/ca/cacert.pem">https://curl.haxx.se/ca/cacert.pem</a> 将文件<code>cacert.pem</code>下载至 <code>C:\RailsInstaller\cacert.pem</code></p>
<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set SSL_CERT_FILE&#x3D;C:\RailsInstaller\cacert.pem</span><br></pre></td></tr></table></figure>

<p>就成功了，不会再出现 SSL 错误了。</p>
<p>最后原文中说，为了长久设置，将这个目录存入控制面板中。我没理解是什么意思，是指环境变量吗？有朋友知道的话，欢迎留言告知我。</p>
<p>我存入环境变量后，还是会出现 SSL 错误，这时再次执行上面那条命令即可。</p>
<h2 id="jekyll-paginate-依赖缺失"><a href="#jekyll-paginate-依赖缺失" class="headerlink" title="jekyll-paginate 依赖缺失"></a>jekyll-paginate 依赖缺失</h2><p>因为 jekyll 3 中默认安装已经没有这个分页组件了，官方把这个分页组件插件化了，因此要独立安装。详情见 <a href="https://jekyllrb.com/docs/pagination/">https://jekyllrb.com/docs/pagination/</a>。</p>
<h3 id="错误呈现-1"><a href="#错误呈现-1" class="headerlink" title="错误呈现"></a>错误呈现</h3><p>在启动 jekyll 服务的时候出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jekyll serve</span><br><span class="line">Configuration file: c:&#x2F;gitWorkSpace&#x2F;blog-based-on-jekyll-3&#x2F;_config.yml</span><br><span class="line">  Dependency Error: Yikes! It looks like you don&#39;t have jekyll-paginate or one of its dependencies installed. In order to use Jekyll as currently configured, you&#39;ll need to install this gem. The full error message from Ruby is: &#39;cannot load such file -- jekyll-paginate&#39; If you run into trouble, you can find helpful resources at http:&#x2F;&#x2F;jekyllrb.com&#x2F;help&#x2F;!</span><br><span class="line">jekyll 3.1.2 | Error:  jekyll-paginate</span><br></pre></td></tr></table></figure>

<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>我们安装这个插件到本地即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install jekyll-paginate</span><br><span class="line">Fetching: jekyll-paginate-1.1.0.gem (100%)</span><br><span class="line">Successfully installed jekyll-paginate-1.1.0</span><br><span class="line">Parsing documentation for jekyll-paginate-1.1.0</span><br><span class="line">Installing ri documentation for jekyll-paginate-1.1.0</span><br><span class="line">Done installing documentation for jekyll-paginate after 3 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure>

<h2 id="被-Foxit-pdf-reader-占用4000端口"><a href="#被-Foxit-pdf-reader-占用4000端口" class="headerlink" title="被 Foxit pdf reader 占用4000端口"></a>被 Foxit pdf reader 占用4000端口</h2><h3 id="错误呈现-2"><a href="#错误呈现-2" class="headerlink" title="错误呈现"></a>错误呈现</h3><p>在本地使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jekyll serve</span><br></pre></td></tr></table></figure>

<p>出现错误，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jekyll serve</span><br><span class="line">Configuration file: E:&#x2F;GitWorkSpace&#x2F;blog&#x2F;_config.yml</span><br><span class="line">           Source: E:&#x2F;GitWorkSpace&#x2F;blog</span><br><span class="line">      Destination: E:&#x2F;GitWorkSpace&#x2F;blog&#x2F;_site</span><br><span class="line">Incremental build: disabled. Enable with --incremental</span><br><span class="line">     Generating...</span><br><span class="line">                   done in 0.547 seconds.</span><br><span class="line"> Please add the following to your Gemfile to avoid polling for changes:</span><br><span class="line">   gem &#39;wdm&#39;, &#39;&gt;&#x3D; 0.1.0&#39; if Gem.win_platform?</span><br><span class="line">Auto-regeneration: enabled for &#39;E:&#x2F;GitWorkSpace&#x2F;blog&#39;</span><br><span class="line">Configuration file: E:&#x2F;GitWorkSpace&#x2F;blog&#x2F;_config.yml</span><br><span class="line">jekyll 3.1.1 | Error:  Permission denied - bind(2) for 127.0.0.1:4000</span><br></pre></td></tr></table></figure>

<p>网上查阅后，这篇博文解决了我的问题。<a href="http://lxconan.github.io/2016/01/07/who-is-using-my-port/">谁占了我的端口 for Windows –By Liu Xia, ThoughtWorks Senior Consultant. .NET Expert</a></p>
<p>上述报错主要原因是，jekyll 启动使用的4000端口被福昕pdf阅读器的自动更新进程占用了，关掉这个进程，jekyll在本地调试启动服务时就没有问题了。</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>简单的解决方法是：</p>
<p>输入命令，查看各端口被占用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>

<p>找到4000端口被占用的<code>PID</code></p>
<p>我的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协议  本地地址          外部地址          状态           PID</span><br><span class="line">TCP  0.0.0.0:80        0.0.0.0:0         LISTENING     4</span><br><span class="line">TCP  0.0.0.0:135       0.0.0.0:0         LISTENING     836</span><br><span class="line">TCP  0.0.0.0:445       0.0.0.0:0         LISTENING     4</span><br><span class="line">TCP  0.0.0.0:1801      0.0.0.0:0         LISTENING     2312</span><br><span class="line">TCP  0.0.0.0:2103      0.0.0.0:0         LISTENING     2312</span><br><span class="line">TCP  0.0.0.0:2105      0.0.0.0:0         LISTENING     2312</span><br><span class="line">TCP  0.0.0.0:2107      0.0.0.0:0         LISTENING     2312</span><br><span class="line">TCP  0.0.0.0:3306      0.0.0.0:0         LISTENING     2404</span><br><span class="line">TCP  0.0.0.0:3389      0.0.0.0:0         LISTENING     1172</span><br><span class="line">TCP  0.0.0.0:49664     0.0.0.0:0         LISTENING     584</span><br><span class="line">TCP  0.0.0.0:49665     0.0.0.0:0         LISTENING     1072</span><br><span class="line">TCP  0.0.0.0:49666     0.0.0.0:0         LISTENING     460</span><br><span class="line">TCP  0.0.0.0:49667     0.0.0.0:0         LISTENING     1000</span><br><span class="line">TCP  0.0.0.0:49670     0.0.0.0:0         LISTENING     696</span><br><span class="line">TCP  0.0.0.0:49678     0.0.0.0:0         LISTENING     2312</span><br><span class="line">TCP  0.0.0.0:49692     0.0.0.0:0         LISTENING     688</span><br><span class="line">TCP  127.0.0.1:4000    0.0.0.0:0         LISTENING     2476</span><br><span class="line">TCP  127.0.0.1:4000    127.0.0.1:55160   ESTABLISHED   2476</span><br><span class="line">TCP  127.0.0.1:4012    0.0.0.0:0         LISTENING     12724</span><br></pre></td></tr></table></figure>

<p>可以看到4000端口的PID是2476。下面查看是什么进程，命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tasklist &#x2F;svc &#x2F;FI &quot;PID eq 2476&quot;</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">映像名称                       PID 服务</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">FoxitProtect.exe              2476 FxService</span><br></pre></td></tr></table></figure>

<p>可以看到正是福昕阅读器。下面关掉这个服务就好了。在 win10 中进入任务管理器，选择服务选项卡，关闭这个服务就好了，如下图：</p>
<p><img src="http://ww4.sinaimg.cn/large/7011d6cfjw1f1ty28wwj4j20g00aiju7.jpg"></p>
<p>当然也可以在启动jekyll服务的时候指定端口号，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jekyll serve --port 3000</span><br></pre></td></tr></table></figure>

<p>这样在浏览器中输入 <a href="http://localhost:3000/">http://localhost:3000/</a> 就可以访问了。</p>
<p>还可以在配置文件<code>_config.yml</code>中添加端口号设置（参考<a href="https://jekyllrb.com/docs/configuration/#serve-command-options">官网文档-Serve Command OptionsPermalink</a>），如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># port</span><br><span class="line">port: 1234</span><br></pre></td></tr></table></figure>

<p>此时，启动jekyll服务后，访问 <a href="http://localhost:1234/">http://localhost:1234/</a> 即可</p>
]]></content>
      <categories>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 语言精粹笔记1-语法、对象、函数</title>
    <url>/2021/05/08/2016/06/JavaScript-good-parts-note1/</url>
    <content><![CDATA[<p>记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。</p>
<p><img src="https://img3.doubanio.com/lpic/s3651235.jpg"></p>
<p>原书中第一章为精华，做了一些周边介绍，略去。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>这里说一下JavaScript的注释，一种是 <code>/* */</code> 包围的块注释，另一种是 <code>//</code> 开头的行注释。</p>
<p>因为块注释的字符可能是JavaScript中正则表达式字面量，因此不是很安全，如：</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    var rm_a = /a*/</span>.match(s)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符由一个字母开头，后面可选择性的加上一个或多个字母、数字或下划线。要避免保留字。</p>
<p>标识符被用于语句、变量、参数、属性名、运算符和标记。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>可以存在指数部分，100和1e2完全相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> === <span class="number">1e2</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用<code>isNaN</code>来检测<code>NaN</code>。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>当年 JavaScript 被创建的时候，Unicode 是16位字符集，因此 JavaScript 字符串是16位的。</p>
<p>用双引号或单引号包裹。</p>
<p>重点说一下转义字符<code>\</code></p>
<p>反斜杠后面可以跟<code>&quot;</code>, <code>&#39;</code>, <code>\</code>, <code>/</code>, <code>b</code> (backspace), <code>f</code> (formfeed), <code>n</code>, <code>r</code> (carriage return), <code>t</code>, <code>u1234</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span> === <span class="string">&#x27;\u0041&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>每个<code>&lt;script&gt;</code>标签的内容被一起抛到一个公共的全局名字空间中。</p>
<p><code>&#123;...&#125;</code>代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。</p>
<p>下列值当做假：</p>
<ul>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>&#39;&#39;</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
</ul>
<p>其他所有值都当做真</p>
<p><code>for in</code>语句枚举对象的所有属性名（键名），使用<code>object.hasOwnProperty(variable)</code>来确定这个属性名是该对象成员，还是来自原型链。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (myvar <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(myvar)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>运算符优先级</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code> <code>[]</code> <code>()</code></td>
<td>提取属性与调用函数</td>
</tr>
<tr>
<td><code>delete</code> <code>new</code> <code>typeof</code> <code>+</code> <code>-</code> <code>!</code></td>
<td>一元运算符</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td></td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td></td>
</tr>
<tr>
<td><code>&gt;=</code> <code>&lt;=</code> <code>&gt;</code> <code>&lt;</code></td>
<td></td>
</tr>
<tr>
<td><code>===</code> <code>!==</code></td>
<td></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td>`</td>
<td></td>
</tr>
<tr>
<td><code>?:</code></td>
<td>三目</td>
</tr>
</tbody></table>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>对象字面量是一种可以方便地按指定规格创建新对象的表示法。</p>
<p>数组字面量是一种可以方便地按指定规格创建新数组的表示法。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数字面量定义了函数值。后续章节详谈。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是属性的容器，每一个属性都拥有名字和值。属性的名字可以是包含空字符串在内的任意字符串。属性的值可以是除<code>undefined</code>值之外的任何值。</p>
<p>JavaScript 包含一种原型链的特性，允许对象继承另一个对象的属性。正确地使用它能减少对象初始化时消耗的时间和内存。</p>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> empty_object = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stooge = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Haoyang&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Gao&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stooge.firstName); <span class="comment">// Haoyang</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge[<span class="string">&#x27;firstName&#x27;</span>]); <span class="comment">// Haoyang</span></span><br></pre></td></tr></table></figure>

<p>不存在的属性返回<code>undefined</code>。</p>
<p>使用<code>||</code>来填充默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stooge.firstName || <span class="string">&#x27;Joe&#x27;</span>); <span class="comment">// Haoyang</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge.age || <span class="number">25</span>); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>直接使用赋值语句更新，若不存在这个属性，则作为扩充操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">stooge.firstName = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">stooge.nickName = <span class="string">&#x27;peip&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge) <span class="comment">//Object &#123;firstName: &quot;aaa&quot;, lastName: &quot;Gao&quot;, nickName: &quot;peip&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>对象通过引用来传递他们永远不会被复制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = stooge</span><br><span class="line">x.hair = <span class="string">&#x27;black&#x27;</span></span><br><span class="line">stooge.hair <span class="comment">//&quot;black&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每一个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过字面量创建的对象都连接到<code>Object.prototype</code>，它是JavaScript中的标配对象。</p>
<p>可以使用<code>Object.create()</code>方法创建一个使用原对象作为其原型的新对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherStooge = <span class="built_in">Object</span>.create(stooge)</span><br><span class="line">anotherStooge.firstName <span class="comment">//&quot;aaa&quot;</span></span><br><span class="line">anotherStooge.firstName = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">anotherStooge.firstName <span class="comment">//&quot;bbb&quot;</span></span><br><span class="line">anotherStooge.hair <span class="comment">//&quot;black&quot;</span></span><br></pre></td></tr></table></figure>

<p>新对象先查找自己的属性，若不存在则会向原型方向查找。</p>
<p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4ieu7focqj207h05caaf.jpg"></p>
<p>当我们对某个对象作出改变时，不会触及该对象的原型。</p>
<p>原型关系是一种动态关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>检查对象并确定对象有什么属性是很容易的事情，只要试着去检索该属性并验证取得的值。</p>
<p><code>typeof</code>用来确定对象属性的类型。</p>
<p><code>hasOwnProperty</code>，若对象拥有独有的属性，它将返回<code>true</code>。不会检查原型链。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用<code>for in</code>可以遍历一个对象中的所有属性名，包括原型链上的属性名。可以使用<code>hasOwnProperty</code>过滤原型链上的属性，使用<code>typeof</code>来排除函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> anotherStooge) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anotherStooge.hasOwnProperty(name) &amp;&amp; <span class="keyword">typeof</span> anotherStooge[name] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">&#x27;---&gt;&#x27;</span> + anotherStooge[name])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// firstName---&gt;bbb</span></span><br></pre></td></tr></table></figure>

<p>属性名是无序的，若想保持顺序应使用数组和<code>for</code>循环。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delete</code>可以用来删除对象的属性。若对象包含该属性，则会被移除。它不会触及原型链中的任何对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">anotherStooge.firstName <span class="comment">//&quot;bbb&quot;</span></span><br><span class="line"><span class="keyword">delete</span> anotherStooge.firstName</span><br><span class="line">anotherStooge.firstName <span class="comment">//&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h3><p>JavaScript 可以随意的定义全局变量来容纳应用的所有资源。但这会削弱程序的灵活性，应避免使用全局变量。</p>
<p>最小化使用全局变量的方法之一是为应用只创建一个唯一的全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.stooge = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.flight = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一章将使用闭包来进行信息隐藏，是另一种有效减少全局污染的方法。</p>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>JavaScript 中的函数就是对象。函数对象连接到<code>Function.prototype</code>（该原型对象本身连接到<code>Object.prototype</code>）。每个函数对象在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。</p>
<p>函数对象在创建时也随配有一个<code>prototype</code>属性。它的值是一个拥有<code>constructor</code>属性且值即为该函数对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4lrei2b3pj208f06et95.jpg"></p>
<p>因为函数是对象，所以可以像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。函数也可以拥有方法。</p>
<p>函数的与众不同之处在于可以被调用。</p>
<h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>函数对象通过函数字面量来创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数字面量包含4部分，分别是：保留字 function、函数名、参数、花括号中的语句。</p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，还有两个附加参数：<code>this</code>和<code>arguments</code>。参数<code>this</code>在面向对象编程中非常重要，它的值取决于调用的模式。JavaScript中一共有4中调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式。</p>
<p>实参和形参个数不匹配时，不会有运行时错误。实参过多时，超出的实参被忽略。形参过多时，缺失的值被替换为<code>undefined</code>。</p>
<p>下面的内容也可以参考我以前的博文 <a href="http://gaohaoyang.github.io/2015/06/12/JavaScript-this/">JavaScript 中的 this</a></p>
<h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，<code>this</code>被绑定到该对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params">inc</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">&#x27;number&#x27;</span> ? inc : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.increment()</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">myObject.increment(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p>当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。</p>
<p>此时<code>this</code>被绑定到全局对象。即时是内部函数也会将<code>this</code>绑定到全局对象。</p>
<p>可以在函数内创建一个属性并赋值为<code>this</code>来解决这个问题。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.double = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        that.value = add(that.value, that.value)</span><br><span class="line">    &#125;</span><br><span class="line">    helper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.double()</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>JavaScript是一门基于原型继承的语言。对象可以直接从其他对象继承属性。该语言是无类型的。</p>
<p>如果在一个函数前面带上<code>new</code>来调用，那么背地里将会创建一个连接到该函数的<code>prototype</code>成员的新对象，同时<code>this</code>会被绑定到那个新对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建构造器函数</span></span><br><span class="line"><span class="keyword">var</span> Quo = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.status = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Que的所有实例提供一个公共方法</span></span><br><span class="line">Quo.prototype.getStatus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">&#x27;confused&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myQuo.getStatus()) <span class="comment">//confused</span></span><br></pre></td></tr></table></figure>

<p>书中不推荐这种形式的构造器函数，下一章有更好的解决方案。</p>
<h4 id="Apply-调用模式"><a href="#Apply-调用模式" class="headerlink" title="Apply 调用模式"></a>Apply 调用模式</h4><p><code>apply</code>方法让我们构建一个参数数组传递给调用函数。他也允许我们选择<code>this</code>的值。<code>apply</code>方法接受两个参数，第一个是要绑定给<code>this</code>的值，第二个是参数数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> sum = add.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> statusObject = &#123;</span><br><span class="line">    status: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status = Quo.prototype.getStatus.apply(statusObject)</span><br><span class="line"><span class="built_in">console</span>.log(status) <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>当函数被调用时，会得到一个<code>arguments</code>数组。通过此参数可以访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形参的多余参数。这使得编写一个无须指定参数个数的函数成为可能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)) <span class="comment">//45</span></span><br></pre></td></tr></table></figure>

<p>因语言的设计错误，<code>arguments</code>并不是一个真正的数组。是一个“类似数组”的对象。有<code>length</code>属性，但没有任何数组的方法。</p>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>函数执行时遇到关闭函数体的<code>&#125;</code>时结束。然后把控制权交还给调用该函数的程序。</p>
<p><code>return</code>可以使函数提前返回，不在执行余下的语句。</p>
<p>函数总是会返回一个值，若没有指定，则返回<code>undefined</code>。</p>
<p>若函数调用时在前面加上了<code>new</code>前缀，且返回值不是一个对象的时候，则返回<code>this</code>（该新对象）。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常是干扰程序的正常流畅的不寻常的事故。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> b !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> &#123;</span><br><span class="line">            name: <span class="string">&#x27;TypeError&#x27;</span>,</span><br><span class="line">            message: <span class="string">&#x27;add needs numbers&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="string">&#x27;a&#x27;</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4mprafcvhj20ml00xjrj.jpg"></p>
<p><code>throw</code>语句中断函数的执行。抛出一个<code>exception</code>对象，该对象包含一个用来识别异常类型的<code>name</code>属性和一个描述性的<code>message</code>属性。也可以自定义其他属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> try_it = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        add2(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.name + <span class="string">&#x27;: &#x27;</span> + e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">try_it() <span class="comment">//TypeError: add needs numbers</span></span><br></pre></td></tr></table></figure>

<p>如果在<code>try</code>代码块内抛出一个异常，控制权就会跳转到它的<code>catch</code>语句中。</p>
<h3 id="扩充类型的功能"><a href="#扩充类型的功能" class="headerlink" title="扩充类型的功能"></a>扩充类型的功能</h3><p>JavaScript 允许给语言的基本类型扩充功能。通过<code>Object.prototype</code>添加方法，可以让该方法对所有对象都适用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先添加方法使得该方法对所有函数可用</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.prototype[name] = func</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个取整方法</span></span><br><span class="line"><span class="built_in">Number</span>.method(<span class="string">&#x27;integer&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>[<span class="built_in">this</span> &lt; <span class="number">0</span> ? <span class="string">&#x27;ceil&#x27;</span> : <span class="string">&#x27;floor&#x27;</span>](<span class="built_in">this</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log((-<span class="number">10</span> / <span class="number">3</span>).integer()) <span class="comment">//-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 trim()</span></span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">&#x27;trim&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;  hello alibaba  &#x27;</span>.trim()) <span class="comment">//hello alibaba</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 原型继承是动态的，因此新的方法立刻被赋予到所有的对象实例上，即使对象实例是在方法被增加之前就创建好了。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数就是会直接或者间接地调用自身的一种函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> walkTheDom = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node, func</span>) </span>&#123;</span><br><span class="line">    func(node)</span><br><span class="line">    node = node.firstChild</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        walk(node, func)</span><br><span class="line">        node = node.nextSibling</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getElementsByAttribute = <span class="function"><span class="keyword">function</span>(<span class="params">att, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = []</span><br><span class="line">    walkTheDom(<span class="built_in">document</span>.body, <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> actual = node.nodeType === <span class="number">1</span> &amp;&amp; node.getAttribute(att)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> actual === <span class="string">&#x27;string&#x27;</span> &amp;&amp; (actual === value || <span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)) &#123;</span><br><span class="line">            results.push(node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在知乎主页上操作</span></span><br><span class="line"><span class="built_in">console</span>.log(getElementsByAttribute(<span class="string">&#x27;data-za-module&#x27;</span>, <span class="string">&#x27;AnswerItem&#x27;</span>))</span><br><span class="line"><span class="comment">//得到下列数据</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域控制着变量与参数的可见性及生命周期。它减少了名称冲突，并提供了自动内存管理。</p>
<p>无块级作用域。</p>
<p>有函数作用域。</p>
<p>建议在函数体的顶部声明函数中可能用到的所有变量。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>作用域的好处是内部函数可以访问定义他们的外部函数的参数和变量（除了<code>this</code>和<code>arguments</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quo = <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get_status: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> status</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myQuo = quo(<span class="string">&#x27;amazed&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myQuo.get_status()) <span class="comment">//amazed</span></span><br></pre></td></tr></table></figure>
<p>狭义的说，返回的那个对象即闭包，它里面的方法可以访问它被创建时所处的上下文环境。</p>
<p>避免在循环中创建函数，容易引起混淆。可以现在循环之外创建一个辅助函数，让辅助函数在返回一个绑定了当前<code>i</code>值的函数，这样就不会导致混淆了。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>将一个函数作为参数，一旦接收到响应，再调用这个函数。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>可以用函数和闭包构造模块。</p>
<p>模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可访问到的地方。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numberCal = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> half = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> double = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tribble = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        half: half,</span><br><span class="line">        double: double,</span><br><span class="line">        tribble: tribble</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.half(<span class="number">5</span>)) <span class="comment">//2.5</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.half(<span class="number">6</span>)) <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.double(<span class="number">7</span>)) <span class="comment">//14</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.tribble(<span class="number">7</span>)) <span class="comment">//21</span></span><br></pre></td></tr></table></figure>

<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>如果让方法返回<code>this</code>而不是默认的<code>undefined</code>，就可以启用级联，即连续调用。</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。</p>
<p>详情见以前的博文 <a href="http://gaohaoyang.github.io/2015/06/11/JavaScript-function/#bind--currying">JavaScript 函数 -bind 与 currying</a>。</p>
<h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象 函数 this 闭包 面向对象 作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 语言精粹笔记2-继承、数组、正则表达式</title>
    <url>/2021/05/08/2016/06/JavaScript-good-parts-note2/</url>
    <content><![CDATA[<p>记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的两大好处：代码重用，引入一套类型系统的规范。</p>
<span id="more"></span>
<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>JavaScript 通过构造器函数产生对象。</p>
<p>构造器调用模式，即用<code>new</code>前缀去调用一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Mammal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mammal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mammal.prototype.says = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.saying || <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMammal = <span class="keyword">new</span> Mammal(<span class="string">&#x27;Herb&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myMammal.getName()) <span class="comment">//Herb</span></span><br></pre></td></tr></table></figure>

<p>书中不推荐这样的写法。有很多风险。若忘记添加<code>new</code>前缀，<code>this</code>无法绑定到新的对象上。而是绑定到了全局对象上，破坏了全局变量环境。</p>
<h3 id="对象说明符"><a href="#对象说明符" class="headerlink" title="对象说明符"></a>对象说明符</h3><p>上一节中的构造器可能要接受一大串参数。我们可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = Maker(&#123;</span><br><span class="line">    first: f,</span><br><span class="line">    middle: m,</span><br><span class="line">    last: l,</span><br><span class="line">    state: s,</span><br><span class="line">    city: c</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将JSON对象传递给构造器，而它返回一个构造完全的对象。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在一个纯粹的原型模式中，我们将摒弃类，转而专注于对象。一个新对象可以继承一个就对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMammal = &#123;</span><br><span class="line">    name: <span class="string">&#x27;MM&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;,</span><br><span class="line">    says: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.saying || <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCat = <span class="built_in">Object</span>.create(myMammal)</span><br><span class="line">myCat.name = <span class="string">&#x27;Kitty&#x27;</span></span><br><span class="line">myCat.saying = <span class="string">&#x27;meow&#x27;</span></span><br><span class="line">myCat.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Kitty is running&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">myCat.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.says + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.says</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种差异化继承。</p>
<h3 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h3><p>前文看到的继承模式没法保护隐私。对象的所有属性都是可见的。无法得到私有变量和私有函数。为了解决这一问题，我们有模块模式。</p>
<p>构造一个生成对象的函数需要4步骤：</p>
<ol>
<li>创建一个新对象。</li>
<li>有选择的定义私有变量和方法。</li>
<li>给这个新对象扩充方法。</li>
<li>返回那个新对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mammal = <span class="function"><span class="keyword">function</span>(<span class="params">spec</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    that.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spec.name</span><br><span class="line">    &#125;</span><br><span class="line">    that.says = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spec.saying || <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMammal = mammal(&#123;</span><br><span class="line">    name: <span class="string">&#x27;Herb&#x27;</span>,</span><br><span class="line">    saying: <span class="string">&#x27;Cheers!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMammal.getName()) <span class="comment">//Herb</span></span><br><span class="line"><span class="built_in">console</span>.log(myMammal.says()) <span class="comment">//Cheers!</span></span><br></pre></td></tr></table></figure>

<p>也可以参考上一篇文章，<a href="http://gaohaoyang.github.io/2016/06/07/JavaScript-good-parts-note1/#section-34">JavaScript 语言精粹笔记1-语法、对象、函数 之模块部分</a>。</p>
<h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>这一部分看的不是特别懂，我想等我学完ES2015中的类和模块部分后再看看吧。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>一个数组字面量是在一对方括号中包围零个或多个用逗号分隔的值的表达式。</p>
<p>再大多数语言中，一个数组的多有元素都要求是相同的类型。JavaScript 允许数组包含任意混合类型的值。</p>
<h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>JavaScript 数组的<code>length</code>属性是没有上界的。如果用大于或等于当前<code>length</code>的数字作为下标来存储一个元素，那么<code>length</code>值会被增大以容纳新元素，不会发生数组越界错误。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>数组也是对象，可以用<code>delete</code>来删除元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;wu&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> numbers[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">0</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.length) <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>splice</code>方法，进行删除和修改操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">0</span>]) <span class="comment">//two</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.length) <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用常规<code>for</code>循环即可，可以保证数组的顺序。</p>
<h3 id="容易混淆的地方"><a href="#容易混淆的地方" class="headerlink" title="容易混淆的地方"></a>容易混淆的地方</h3><p>当属性名是小而连续的整数时，应该使用数组，否则使用对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>返回数组的类型是<code>object</code>，没有任何意义。</p>
<p>判断数组类型的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(numbers)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript 5.1 (ECMA-262) 和 ECMAScript 2015 (6th Edition, ECMA-262) 标准中的方法。</p>
<p>或者下面这个方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> is_array = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.apply(value) === <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(is_array(numbers)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>数组的方法被存储在<code>Array.prototype</code>中的函数。</p>
<p>数组是对象，因此<code>Array.prototype</code>也是可扩充的。</p>
<h3 id="指定初始值"><a href="#指定初始值" class="headerlink" title="指定初始值"></a>指定初始值</h3><p>JavaScript 的数组不会预制值。</p>
<p>JavaScript 没有多维数组，单项大多数类 C 语言一样，支持元素为数组的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = [</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line"><span class="built_in">console</span>.log(matrix[<span class="number">1</span>][<span class="number">2</span>]) <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>关于正则表达式，以前的博文写的比较多了，详情见：</p>
<p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-10">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分1</a></p>
<p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-12">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分2</a></p>
<p><a href="http://gaohaoyang.github.io/2016/05/06/regular-expression-group/">浅谈正则表达式中的分组和引用</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承 对象 原型 Array 正则</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 语言精粹笔记3-方法、毒瘤等</title>
    <url>/2021/05/08/2016/06/JavaScript-good-parts-note3/</url>
    <content><![CDATA[<p>记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>这一章主要介绍了一些方法集。这里写几个我不太熟悉的方法和要点吧。</p>
<span id="more"></span>
<ul>
<li><p><code>array.join()</code></p>
<blockquote>
<p>对于IE6/7，使用<code>array.join()</code>连接大量字符串的效率确实优于使用<code>+</code>元素运算符。但是目前主流的浏览器，包括IE8以后的版本，都对<code>+</code>元素运算符连接字符串做了特别优化，性能已经显著高于<code>array.join()</code>。</p>
</blockquote>
</li>
<li><p><code>number.toExponential(fractionDigits)</code></p>
<p>  把这个<code>number</code>转换成一个指数形式的字符串。</p>
</li>
<li><p><code>number.toFixed(fractionDigits)</code></p>
<p>  将这个<code>number</code>转换成一个十进制形式的字符串。</p>
</li>
</ul>
<h2 id="毒瘤"><a href="#毒瘤" class="headerlink" title="毒瘤"></a>毒瘤</h2><ul>
<li><p>注意全局变量的引入。</p>
</li>
<li><p>JavaScript 中 Unicode 是16位的。包含65536个字符（基本多文种平面 Basic Multilingual Plane）。剩下的百万字符中的每一个都可以用一对字符来表示。Unicode 把一对字符视为一个单一的字符，而 JavaScript 认为一对字符是两个不同的字符。</p>
</li>
<li><p>检测<code>null</code>的方式。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line">myValue === <span class="literal">null</span> <span class="comment">//检测 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myValue &amp;&amp; <span class="keyword">typeof</span> myValue === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// myValue 是一个对象或数组！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>parseInt</code> 把字符串转化为整数的函数。它遇到非数字时会停止解析，所以<code>parseInt(&#39;16&#39;)</code>和<code>parseInt(&#39;16ton&#39;)</code>产生相同的结果。</p>
<p>  如果该字符串第一个字符是0，那么该字符串会基于八进制而不是十进制来求职。在八进制中，8和9不是数字，所以<code>parseInt(&#39;08&#39;)</code>和<code>parseInt(&#39;09&#39;)</code>都产生0作为结果。但<code>parseInt()</code>可以接受基数，因此<code>parseInt(&#39;08&#39;,10)</code>结果为8，建议总是加上这个基数参数。</p>
</li>
<li><p>JavaScript 的对象永远不会是真的空对象，因为它们可以送原型链中取得成员属性。</p>
</li>
</ul>
<h2 id="糟粕"><a href="#糟粕" class="headerlink" title="糟粕"></a>糟粕</h2><ul>
<li><p>避免使用<code>with</code>语句。</p>
</li>
<li><p>避免使用<code>eval</code>语句。</p>
</li>
<li><p><code>continue</code>可能会降低运算性能。</p>
</li>
<li><p>位运算符在 JavaScript 会非常慢。</p>
<p>  Java 里，位运算符处理的是整数。JavaScript 没有整数类型，它只有双精度的浮点数，因此，位运算符把它们的数字运算数先转换为整数，执行运算，在转换回去。JavaScript 的执行环境一般接触不到硬件，所以非常慢。</p>
</li>
<li><p>避免使用包装对象。<code>new Object</code>和<code>new Array</code>等。</p>
</li>
<li><p>避免使用<code>void</code>。</p>
</li>
</ul>
<p>本系列结束。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 babel</title>
    <url>/2021/05/08/2016/06/how-to-use-babel/</url>
    <content><![CDATA[<p><a href="https://babeljs.io/">Babel</a> 用于将 ES6 的代码转化为 ES5，使得 ES6 可以在目前的浏览器环境下使用。学习使用 babel 是为了使用 ES2015 做准备。本文将介绍如何使用 babel，以及一些相关的配置。</p>
<span id="more"></span>



<p><img src="https://babeljs.io/images/logo.svg"></p>
<p>学习 Babel 可以通过其手册 Babel handbook。</p>
<ul>
<li><a href="https://github.com/thejameskyle/babel-handbook">babel-handbook</a></li>
</ul>
<p>其中包含多语言版本，分为<a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md">用户手册</a>和<a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md">插件手册</a>。这是一个很好的学习 Babel 的资料。</p>
<h2 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h2><p>在 node 和 npm 环境安装好的前提下，安装 babel，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --global babel-cli</span><br></pre></td></tr></table></figure>

<p>安装完成后就可以编译文件了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">babel main.js</span><br></pre></td></tr></table></figure>

<p>编译后的文件显示在终端上，可以添加其他命令让它输出到指定文件下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">babel example.js --out-file compiled.js</span><br><span class="line">或</span><br><span class="line">babel example.js -o compiled.js</span><br></pre></td></tr></table></figure>

<p>或将整个目录编译成一个新的目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">babel src --out-dir lib</span><br><span class="line">或</span><br><span class="line">babel src -d lib</span><br></pre></td></tr></table></figure>

<p>但这很麻烦，并且并不是一个很好的解决方案，请看下一节项目内运行 babel-cli。</p>
<h2 id="在项目内运行-babel-cli"><a href="#在项目内运行-babel-cli" class="headerlink" title="在项目内运行 babel-cli"></a>在项目内运行 babel-cli</h2><p>初始化项目</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>再安装 babel-cli</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure>

<p>项目中的<code>package.json</code>应该包含如下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;learn-es6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;babel-cli&quot;</span>: <span class="string">&quot;^6.10.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 npm scripts 命令。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;learn-es6&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line"><span class="addition">+   &quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="addition">+     &quot;build&quot;: &quot;babel src -d lib&quot;</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-cli&quot;: &quot;^6.10.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时在终端里运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>还不能成功编译，因为没有配置<code>.babelrc</code>文件。</p>
<h2 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置<code>.babelrc</code></h2><p>通过配置<code>.babelrc</code>来告诉 babel 来做什么。</p>
<p>在项目的根路径下创建<code>.babelrc</code>文件。然后输入以下内容作为开始：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让 babel 将 ES2015 转化为 ES5，我们要安装如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br></pre></td></tr></table></figure>

<p>安装完成后在<code>.babelrc</code>中添加参数：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line"><span class="addition">+       &quot;es2015&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在项目<code>src/main.js</code>中写一些 ES2015 的代码试试吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在终端中输入命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>执行后终端中显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; learn-es6@1.0.0 build c:\gitWorkSpace\learn-es6</span><br><span class="line">&gt; babel src -d lib</span><br></pre></td></tr></table></figure>

<p>然后可以看到目录中出现了<code>lib/main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>即编译成功。</p>
<h2 id="配置-jshintrc"><a href="#配置-jshintrc" class="headerlink" title="配置.jshintrc"></a>配置<code>.jshintrc</code></h2><p>若编辑器中安装了 jshint 语法检查的插件。默认对于 ES2015 的代码可能会报错或者警告，看着可能会不爽。我们可以在配置文件中将它设置为允许 ES2015 的模式。</p>
<p>在项目根目录下创建文件<code>.jshintrc</code>。内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;asi&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;esversion&quot;</span>: <span class="number">2015</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述文件我分别设置了，使用无分号模式，es 版本使用 2015。</p>
<p>关于<code>.jshintrc</code>的更详细配置可以参见官方示例：<a href="https://github.com/jshint/jshint/blob/master/examples/.jshintrc">https://github.com/jshint/jshint/blob/master/examples/.jshintrc</a></p>
<p>好，babel 就说到这里，下面开始进入真正的 ES2015 的学习！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES2015 ES6 ES5 babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 如何 clone 非 master 分支的代码</title>
    <url>/2021/05/08/2016/07/git-clone-not-master-branch/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们每次使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@gitlab.xxx.com:xxxxx.git</span><br></pre></td></tr></table></figure>

<p>默认 clone 的是这个仓库的 master 分支。如果最新的代码不在 master 分支上，该如何拿到呢？如下图所示，最新的代码可能在<code>daily/1.4.1</code>分支上，我们希望拿到这个分支上的代码。</p>
<span id="more"></span>



<p><img src="https://ooo.0o0.ooo/2016/07/07/577e349ab42ed.png" alt="7f07c8f6deef169ef6be5103bbd3e932f8676bb1.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>刚刚开周会的时候，自己洋洋得意的分享我的解决方案，但是……经过与团队成员的的讨论，自己的方法弱爆了，现在把更优雅的方法写一下。原来写的方法并不太适合用在这个场景里。</strong> 我之前写的方法在文章后面。</p>
<p>直接使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r #查看远程分支</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a #查看所有分支</span><br></pre></td></tr></table></figure>

<p>会显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin&#x2F;HEAD -&gt; origin&#x2F;master</span><br><span class="line">origin&#x2F;daily&#x2F;1.2.2</span><br><span class="line">origin&#x2F;daily&#x2F;1.3.0</span><br><span class="line">origin&#x2F;daily&#x2F;1.4.1</span><br><span class="line">origin&#x2F;develop</span><br><span class="line">origin&#x2F;feature&#x2F;daily-1.0.0</span><br><span class="line">origin&#x2F;master</span><br></pre></td></tr></table></figure>

<p>然后直接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout origin&#x2F;daily&#x2F;1.4.1</span><br></pre></td></tr></table></figure>

<p>就好了。。。</p>
<h2 id="原来的解决方案"><a href="#原来的解决方案" class="headerlink" title="原来的解决方案"></a>原来的解决方案</h2><p><strong>其实我原来写的这个方法更多的是：设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支。</strong></p>
<p>我们在本地先建立一个分支，建议名称和远程的想要同步的分支名称一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch daily&#x2F;1.4.1</span><br></pre></td></tr></table></figure>

<p>在切换到这个本地分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout daily&#x2F;1.4.1</span><br><span class="line"># Switched to branch &#39;daily&#x2F;1.4.1&#39;</span><br></pre></td></tr></table></figure>

<p>接下来就可以去建立上游分支的关联了，但是这个命令比较长，不好记，我们可以直接先<code>pull</code>一下，git 会提示我们相应的操作和命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to&#x3D;origin&#x2F;&lt;branch&gt; daily&#x2F;1.4.1</span><br></pre></td></tr></table></figure>

<p>我们看到最后一行，执行这个命令，即可完成与上游分支的关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;daily&#x2F;1.4.1 daily&#x2F;1.4.1</span><br><span class="line"># Branch daily&#x2F;1.4.1 set up to track remote branch daily&#x2F;1.4.1 from origin.</span><br></pre></td></tr></table></figure>

<p>然后再<code>pull</code>一下就好了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Fisher–Yates shuffle 洗牌算法</title>
    <url>/2021/05/08/2016/10/shuffle-algorithm/</url>
    <content><![CDATA[<p>简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p>
<span id="more"></span>
<p>本文主要介绍这个算法的来源、演变、原理。并举出一个例子为大家清晰的描述每次迭代过程。最后使用 JavaScript 代码将算法实现。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Riffle_shuffle.jpg/320px-Riffle_shuffle.jpg"></p>
<h2 id="Fisher-and-Yates-的原始版"><a href="#Fisher-and-Yates-的原始版" class="headerlink" title="Fisher and Yates 的原始版"></a>Fisher and Yates 的原始版</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Biologist_and_statistician_Ronald_Fisher.jpg/189px-Biologist_and_statistician_Ronald_Fisher.jpg"></p>
<p>Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher（上图） 和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：</p>
<ol>
<li>写下从 1 到 N 的数字</li>
<li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li>
<li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位</li>
<li>重复第 2 步，直到所有的数字都被取出</li>
<li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li>
</ol>
<p>已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。</p>
<h2 id="现代方法"><a href="#现代方法" class="headerlink" title="现代方法"></a>现代方法</h2><p>Fisher–Yates shuffle 算法的现代版本是为计算机设计的。由 Richard Durstenfeld 在1964年 描述。并且是被 Donald E. Knuth 在 《The Art of Computer Programming》 中推广。但是不管是 Durstenfeld 还是 Knuth，都没有在书的第一版中承认这个算法是 Fisher 和 Yates 的研究成果。也许他们并不知道。不过后来出版的 《The Art of Computer Programming》提到了 Fisher 和 Yates 贡献。</p>
<p>现代版本的描述与原始略有不同，因为如果按照原始方法，愚蠢的计算机会花很多无用的时间去计算上述第 3 步的剩余数字。<strong>这里的方法是在每次迭代时交换这个被取出的数字到原始列表的最后</strong>。这样就将时间复杂度从 O(n^2) 减小到了 **O(n)**。算法的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- To shuffle an array a of n elements (indices 0..n-1):</span><br><span class="line">for i from n−1 downto 1 do</span><br><span class="line">     j ← random integer such that 0 ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="迭代步骤演示"><a href="#迭代步骤演示" class="headerlink" title="迭代步骤演示"></a>迭代步骤演示</h3><p>根据每次迭代次数可以用下面的表格，描述这个算法的执行过程</p>
<table>
<thead>
<tr>
<th align="left">随机数取值范围</th>
<th align="left">随机数</th>
<th align="right">原始数据</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="right">1 2 3 4 5 6 7 8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1-8</td>
<td align="left">6</td>
<td align="right">1 2 3 4 5 7 8</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">1-7</td>
<td align="left">2</td>
<td align="right">1 7 3 4 5 8</td>
<td align="left">2 6</td>
</tr>
<tr>
<td align="left">1–6</td>
<td align="left">6</td>
<td align="right">1 7 3 4 5</td>
<td align="left">8 2 6</td>
</tr>
<tr>
<td align="left">1–5</td>
<td align="left">1</td>
<td align="right">5 7 3 4</td>
<td align="left">1 8 2 6</td>
</tr>
<tr>
<td align="left">1–4</td>
<td align="left">3</td>
<td align="right">5 7 4</td>
<td align="left">3 1 8 2 6</td>
</tr>
<tr>
<td align="left">1–3</td>
<td align="left">3</td>
<td align="right">5 7</td>
<td align="left">4 3 1 8 2 6</td>
</tr>
<tr>
<td align="left">1–2</td>
<td align="left">1</td>
<td align="right">7</td>
<td align="left">5 4 3 1 8 2 6</td>
</tr>
</tbody></table>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p>下面这个动画就是整个数组 0-19 的随机排序过程</p>
<iframe height='317' scrolling='no' src='//codepen.io/haoyang/embed/jrvrQq/?height=317&theme-id=dark&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/haoyang/pen/jrvrQq/'>Fisher–Yates shuffle</a> by Chuan shi (<a href='http://codepen.io/haoyang'>@haoyang</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe>

<h2 id="JavaScript-代码实现"><a href="#JavaScript-代码实现" class="headerlink" title="JavaScript 代码实现"></a>JavaScript 代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fisher–Yates shuffle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = input.length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">var</span> itemAtIndex = input[randomIndex];</span><br><span class="line"></span><br><span class="line">        input[randomIndex] = input[i];</span><br><span class="line">        input[i] = itemAtIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式也很简单，直接用数组调用这个方法即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>].shuffle()</span><br><span class="line"></span><br><span class="line"><span class="comment">//[4, 6, 3, 2, 5, 1, 7, 8] // 每次结果都是随机的</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，Fisher–Yates shuffle 算法是一个非常高效又公平的随机排序算法，如果有随机排序数组的需求，用这个就对了！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher–Yates shuffle From Wikipedia</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法 shuffle 乱序 洗牌</tag>
      </tags>
  </entry>
  <entry>
    <title>前端如何写一个精确的倒计时</title>
    <url>/2021/05/08/2016/11/how-to-write-a-count-down/</url>
    <content><![CDATA[<p>关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。</p>
<span id="more"></span>
<p><img src="https://img.alicdn.com/tfs/TB18QnlOpXXXXcVXpXXXXXXXXXX-388-256.png"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>众所周知 setTimeout 或者 setInterval 调用的时候会有微小的误差。有人做了一个 <a href="https://bl.ocks.org/kenpenn/raw/92ebaa71696b4c4c3acd672b1bb3f49a/">demo</a> 来观察这个现象并对其做了修正。短时间的误差倒也可以接受，但是作为一个长时间的倒计时，误差累计就会导致倒计时不准确。</p>
<p>因此我们可以在获取剩余时间的时候，每次 new 一个设备时间，因为设备时间的流逝相对是准确的，并且如果设备打开了网络时间同步，也会解决这个问题。</p>
<p>但是，如果用户修改了设备时间，那么整个倒计时就没有意义了，用户只要将设备时间修改为倒计时的 endTime 就可以轻易看到倒计时结束是页面的变化。因此一开始获取服务端时间就是很重要的。</p>
<p>简单的说，一个简单的精确倒计时原理如下：</p>
<ul>
<li>初始化时请求一次服务器时间 serverTime，再 new 一个设备时间 deviceTime</li>
<li>deviceTime 与 serverTime 的差作为时间偏移修正</li>
<li>每次递归时 new 一个系统时间，解决 setTimeout 不准确的问题</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>获取剩余时间的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取剩余时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>endTime    截止时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>deviceTime 设备时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>serverTime 服务端时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span>            </span>剩余时间对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> getRemainTime = <span class="function">(<span class="params">endTime, deviceTime, serverTime</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> t = endTime - <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()) - serverTime + deviceTime</span><br><span class="line">    <span class="keyword">let</span> seconds = <span class="built_in">Math</span>.floor((t / <span class="number">1000</span>) % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="built_in">Math</span>.floor((t / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">let</span> hours = <span class="built_in">Math</span>.floor((t / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)) % <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">let</span> days = <span class="built_in">Math</span>.floor(t / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>))</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;total&#x27;</span>: t,</span><br><span class="line">        <span class="string">&#x27;days&#x27;</span>: days,</span><br><span class="line">        <span class="string">&#x27;hours&#x27;</span>: hours,</span><br><span class="line">        <span class="string">&#x27;minutes&#x27;</span>: minutes,</span><br><span class="line">        <span class="string">&#x27;seconds&#x27;</span>: seconds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>获取服务器时间可以使用 mtop 接口 <code>mtop.common.getTimestamp</code> </del></p>
<p>然后可以通过下面的方式来使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取服务端时间（获取服务端时间代码略）</span></span><br><span class="line">getServerTime(<span class="function">(<span class="params">serverTime</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    <span class="keyword">let</span> intervalTimer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        <span class="keyword">let</span> remainTime = getRemainTime(endTime, deviceTime, serverTime)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒计时到两个小时内</span></span><br><span class="line">        <span class="keyword">if</span> (remainTime.total &lt;= <span class="number">7200000</span> &amp;&amp; remainTime.total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒计时结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remainTime.total &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(intervalTimer);</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样的的写法也可以做到准确倒计时，同时也比较简洁。不需要隔段时间再去同步一次服务端时间。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在写倒计时的时候遇到了一个坑这里记录一下。</p>
<p><strong>千万别在倒计时结束的时候请求接口</strong>。会让服务端瞬间 QPS 峰值达到非常高。</p>
<p><img src="https://img.alicdn.com/tfs/TB1LBzjOpXXXXcnXpXXXXXXXXXX-154-71.png"></p>
<p>如果在倒计时结束的时候要使用新的数据渲染页面，正确的做法是：</p>
<p>在倒计时结束前的一段时间里，先请求好数据，倒计时结束后，再渲染页面。</p>
<p>关于倒计时，如果你有什么更好的解决方案，欢迎评论交流。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 JavaScript 创建并下载文件</title>
    <url>/2021/05/08/2016/11/js-create-file-and-download/</url>
    <content><![CDATA[<p>本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。</p>
<span id="more"></span>
<h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;String&#125;</span> </span>fileName 文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">var</span> aTag = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    aTag.download = fileName;</span><br><span class="line">    aTag.href = URL.createObjectURL(blob);</span><br><span class="line">    aTag.click();</span><br><span class="line">    URL.revokeObjectURL(blob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单对吧，直接调用这个方法，传入文件名和文件内容，程序新建 a 标签，新建 Blob 对象，将文件名赋给 a 标签，同时将 Blob 对象作为 Url 也赋给 a 标签，模拟点击事件，自动下载成功，最后再回收内存。下面我们来看看具体是怎么操作的。</p>
<p><img src="https://img.alicdn.com/tfs/TB16.GnOpXXXXXdapXXXXXXXXXX-307-134.png"></p>
<h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 对象是一个字节序列。拥有 <code>size</code> 和 <code>type</code> 等属性。</p>
<p>拥有 2 个只读状态 <code>OPEND</code> 和 <code>CLOSED。</code></p>
<p>Blob 对象属于 JavaScript Web APIs 中的 File API 规定的部分，可以参考 W3C 文档中的 <a href="https://www.w3.org/TR/2015/WD-FileAPI-20150421/#blob"> The Blob Interface and Binary Data</a></p>
<p>再回来看看我们的代码里是这么写的，使用了 Blob 的构造函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用方括号的原因是，其构造函数的参数为以下4中：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- ArrayBuffer [TypedArrays] elements.</span></span><br><span class="line"><span class="string">- ArrayBufferView [TypedArrays] elements.</span></span><br><span class="line"><span class="string">- Blob elements.</span></span><br><span class="line"><span class="string">- DOMString [WebIDL] elements.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所谓 `</span><span class="built_in">ArrayBuffer</span><span class="string">` 是一种用于呈现通用、固定长度的二进制数据的类型。详情可以参考 [ArrayBuffer -MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 以及 [ECMAScript2015 标准中的 ArrayBuffer](http://www.ecma-international.org/ecma-262/6.0/#sec-arraybuffer-objects)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Blob URLs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Blob URLs 被创建或注销是使用 `</span>URL<span class="string">` 对象上的方法。这个 `</span>URL<span class="string">` 对象被挂在 `</span>Window<span class="string">` (HTML) 对象下，或者 `</span>WorkerGlobalScope<span class="string">` (Web Workers)对象下。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">拥有以下静态方法 `</span>createObjectURL<span class="string">` 和 `</span>revokeObjectURL<span class="string">`，用于创建一个 blob 对象的 url 和注销这个 blob url。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">详情可查看 [关于创建和注销 Blob URL 的 W3C 标准文档]( https://www.w3.org/TR/2015/WD-FileAPI-20150421/#creating-revoking)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 模拟 click</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">element.click();</span><br></pre></td></tr></table></figure>

<p>在 W3C 中很早就有这个<a href="https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-2651361">规范</a>，不需要写繁琐的模拟事件触发的代码。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前我将这个技术使用在 天猫双十一技术和UED庆功会 的摇火箭大屏游戏中。最后的游戏结果排名，在请求了接口后，在前端直接生成并下载到了本地，作为记录保存。主要也是因为服务端暂时没有提供这个一张表去记录游戏结果，于是采用了前端记录的解决方案。</p>
<p>大家当时都玩的好开心啊，😁。你们的甘其食和全家卡的名单就是这样生成的！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.alloyteam.com/2014/01/use-js-file-download/">在浏览器端用JS创建和下载文件 -alloyteam</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>win10 关闭更新</title>
    <url>/2021/05/08/2018/01/close-win10-update/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为自己的电脑装了双系统（win10 跟Ubuntu16.04），在win10下，有时候每次关机的时候都说要进行更新后进行关机，就是自动更新功能，现在的选项中没有关闭自动更新的选项了，这是一个bug，微软要强制更新。</p>
<span id="more"></span>
<p>我就忍受不了自动更新，会拉取网络，影响我们的上网体验，但是我们不要他自动更新，那怎么办呢，其实还是有解决方法的，下面就介绍怎么关闭自动更新功能！（ps：百度有些人写的其实是win8的自动更新，根本就不是win10的，我这个才是win10的处理方法）希望能帮到你们。</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1 右键点击左下角微软按钮，找到“运行”   也可用键盘的win+R     </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577413-07f3d54cc3ce1538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<p>2 在运行处输入 “services.msc”   点击确定。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577413-2df616c88439415a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<p>3 在弹出来的服务中，找到“Windows Update”</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577413-403c9d7761ad60b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<p>4 选择禁用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577413-1728ba13ad50acfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<p>5 点击确定或者启动就可以了，这时候我们可以看到：<br><img src="http://upload-images.jianshu.io/upload_images/2577413-8d901951002a4bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<p>会多出这两个位置，这样子就设置成功了。</p>
]]></content>
      <categories>
        <category>win10</category>
      </categories>
      <tags>
        <tag>win10 工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>News_scrapy_redis 框架系统</title>
    <url>/2021/05/08/2018/01/python_crawl_words/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文档针对爬虫系统设计目标中相应的场景给出技术方案</p>
<span id="more"></span>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>1、代码复用，功能模块化。可以支持上千个网站的数据爬取；</p>
<p>2、易扩展。爬虫框架易扩展，爬取规则、解析规则、入库规则易扩展，支持框架切换；</p>
<p>3、健壮性、可维护性。对数据爬取过程中的各种异常，例如：断网、反爬升级、爬“脏数据”等，需要实时的监控，以及给出准确的定位。异常处理以及降级措施需要完善；</p>
<p>4、后续扩展为分布式结构；</p>
<p>5、支持功能模块的易调整；</p>
<h2 id="框架使用说明"><a href="#框架使用说明" class="headerlink" title="框架使用说明"></a>框架使用说明</h2><p><strong>News_scrapy_redis4. <a href="https://github.com/xudailong/News_scrapy_redis.git">github地址</a></strong></p>
<ol>
<li><p><code>News_scrapy_redis</code> 基于<code>scrapy_redis</code>实现数据的增量爬取（含去重），支持分布式，支持异常日志等输出，功能模块化。</p>
</li>
<li><p>树结构：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├─.idea</span><br><span class="line">├─Daily_crawler</span><br><span class="line">├─ETL</span><br><span class="line">├─log</span><br><span class="line">├─News_scrapy</span><br><span class="line">│  ├─spiders</span><br><span class="line">│  │  └─__pycache__</span><br><span class="line">│  └─__pycache__</span><br><span class="line">├─News_simhash</span><br><span class="line">└─News_statistics</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>各模块说明：<blockquote>
<p>Daily_crawler：    </p>
</blockquote>
<ul>
<li><code>daily_crawler.cron crontab</code>的定时文件, 定时运行<code>start_crawl.sh</code>脚本</li>
<li><code>start_crawl.sh</code> 启动爬虫模块，并将每次爬取所花费的时间 写入 log/run_time.txt</li>
<li><code>push_urls.py</code> 每次在爬虫之前运行，清空调度队列，并将start_url push到调度队列中</li>
<li><code>news_crawl.sh</code> 执行爬虫模块（增量爬取）， 并自动进行相似文档去重，ETL, 存入mongodb</li>
</ul>
<blockquote>
<p>ETL:（暂时用不到）</p>
</blockquote>
<ul>
<li><code>/Model</code> 存放训练好的词典，语料，TF-IDF，LDA， word2vec模型</li>
<li><code>auto_embedding.py</code> 新闻语料的清洗，以及自动化生成新闻的标题和内容embedding</li>
<li><code>auto_embedding_simhash.py</code> 增加了自动化相似文档的去重</li>
<li><code>stop_words</code> 常用的中文停留词</li>
<li><code>train_step1</code> 训练LDA模型</li>
<li><code>train_step2</code> 训练LDA模型</li>
</ul>
<blockquote>
<p>log:</p>
</blockquote>
<ul>
<li><code>auto_embedding_simhash.log</code> 执行auto_embedding_simhash.py的日志文件</li>
<li><code>crawler.log</code> 执行scrapy-redis爬虫模块的日志文件</li>
<li><code>news_count.log</code> 执行news_statistics.py的日志文件</li>
<li><code>run_time.txt</code> 每次执行爬虫脚本的运行时间</li>
</ul>
<blockquote>
<p>News_data:</p>
</blockquote>
<ul>
<li>每个文件夹是抓每天从各个网站抓取到的新闻</li>
</ul>
<blockquote>
<p>News_scrapy:</p>
</blockquote>
<ul>
<li>基于scrapy-redis的爬虫模块，在scrapy的基础上修改得到</li>
<li>各大网站数据的爬取解析工作主要在该文件中进行</li>
</ul>
<blockquote>
<p>News_simhash（此处只需要进行title的去重）:</p>
</blockquote>
<ul>
<li>实现相似文档的去重</li>
<li>automatic_simhash.py 自动实现相似文档的去重（仅基于新闻内容）</li>
<li><code>near_duplicates.py</code> 对初始化的Simhash_index进行相似新闻内容的去重</li>
</ul>
<blockquote>
<p>News_statistics:</p>
</blockquote>
<ul>
<li><code>news_count.json</code> 每天从各个网站抓取的新闻数量</li>
<li><code>news_statistics.py</code> 统计新闻增量的脚本</li>
</ul>
</li>
</ol>
<h2 id="框架环境"><a href="#框架环境" class="headerlink" title="框架环境"></a>框架环境</h2><ol>
<li>Redis环境环境</li>
<li>scrapy框架环境</li>
<li>python3环境环境</li>
</ol>
<h2 id="框架完善"><a href="#框架完善" class="headerlink" title="框架完善"></a>框架完善</h2><ol>
<li>IP代理池</li>
<li>cookies池 </li>
<li>其他</li>
</ol>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04设置Pycharm桌面快捷键</title>
    <url>/2021/05/08/2017/12/Ubuntu16.04-pycharm-icon-setting/</url>
    <content><![CDATA[<h2 id="Ubuntu下所有的快捷方式都在："><a href="#Ubuntu下所有的快捷方式都在：" class="headerlink" title="Ubuntu下所有的快捷方式都在："></a>Ubuntu下所有的快捷方式都在：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/usr/share/applications</span><br></pre></td></tr></table></figure>

<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>这里我将pycharm下载并解压到了/home/snakeson/developer文件夹下</p>
<p>这里的pycharm.sh是批处理执行文件，prcharm.png是快捷方式图标</p>
<span id="more"></span>
<h2 id="终端打开"><a href="#终端打开" class="headerlink" title="终端打开"></a>终端打开</h2><p>使用Ubuntu终端进行打开：<br>方法一（使用vim）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo vi  /usr/share/applications/pycharm.desktop</span><br></pre></td></tr></table></figure>

<p>方法二（使用gedit）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo gedit  /usr/share/applications/pycharm.desktop</span><br></pre></td></tr></table></figure>





<p>然后就会弹出一个新框：</p>
<h2 id="张贴"><a href="#张贴" class="headerlink" title="张贴"></a>张贴</h2><p>我们将下面的内容贴上去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Name=Pycharm</span><br><span class="line">GenericName=Pycharm3</span><br><span class="line">Comment=Pycharm3:The Python IDE</span><br><span class="line">Exec=<span class="string">&quot;/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.sh&quot;</span> %f</span><br><span class="line">Icon=<span class="regexp">/home/</span>snakeson/developer/pycharm-community-<span class="number">2017.2</span><span class="number">.3</span>/bin/pycharm.png</span><br><span class="line">Terminal=pycharm</span><br><span class="line">Categories=Pycharm;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>注意一定要将Desktop Entry复制进去，也就是上面的全部都要复制进去，这里我们需要替换掉两个地方：<strong>Exec=”xx”<strong>和</strong>Icon=</strong>,这里要替换掉我们的pycharm解压的目录，当然了，我已经替换好了，如果你的目录跟我的目录不一样的话，你得把路径给换了，不管你是pycharm2017还是pycharm2016,，例如Comment什么的都不要改变，只变上面提到的两个路径就可以了。</p>
<h2 id="添加可执行权限"><a href="#添加可执行权限" class="headerlink" title="添加可执行权限"></a>添加可执行权限</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/share/applications/pycharm.desktop</span><br></pre></td></tr></table></figure>

<h2 id="拷贝到桌面"><a href="#拷贝到桌面" class="headerlink" title="拷贝到桌面"></a>拷贝到桌面</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">将/usr/share/applications/pycharm.desktop文件拷贝到桌面，双击即可运行。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Ubuntu Python</tag>
      </tags>
  </entry>
  <entry>
    <title>window下python3环境安装scrapy</title>
    <url>/2021/05/08/2018/01/scrapy-setup-in-win/</url>
    <content><![CDATA[<p>目录：</p>
<h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><blockquote>
<p>python3  3.6.4， win7 64位  </p>
</blockquote>
<span id="more"></span>
<h2 id="初次安装："><a href="#初次安装：" class="headerlink" title="初次安装："></a>初次安装：</h2><blockquote>
<p><code> pip install scrapy</code></p>
</blockquote>
<p>使用这个命令，在win7 64位是怎么也安装不上去的，因为这已经是第二次了，</p>
<p>当这个命令输出完后，会出现一系列的问题。当然了，不用怕，这不是需要解决问题的方法来了嘛。</p>
<p>可能出现需要下载版本对应的visual studio,但是也太大了，或也可以说下载慢。。。。。。但是，我们可以不用去进行下载，只要进行下面几个文件的安装就可以了。</p>
<h2 id="打开网站"><a href="#打开网站" class="headerlink" title="打开网站"></a>打开网站</h2><p>首先你打开这个网站（里面包含了各种编译好的库）：</p>
<blockquote>
<p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml">http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml</a></p>
</blockquote>
<h2 id="安装wheel"><a href="#安装wheel" class="headerlink" title="安装wheel"></a>安装wheel</h2><blockquote>
<p><code> pip install wheel</code></p>
</blockquote>
<p>安装成功的界面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577413-93cab0d529ca1dba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wheel—success.png"></p>
<h2 id="安装-whl文件"><a href="#安装-whl文件" class="headerlink" title="安装.whl文件"></a>安装.whl文件</h2><p>这里需要安装三个.whl文件，而且是全名的安装，</p>
<p>以下三个文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577413-eaf16a31171cd6ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".whl文件.png"></p>
<p>中途可能会出现<code>Failed to build XXXX </code> 或者是<code> twisted</code>等相关的内容</p>
<p>因为scrapy是基于twisted框架的，所以，twisted框架也需要进行安装</p>
<p>当上面三个文件安装好了：</p>
<p>再次运行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scrapy startproject pyjy</span><br></pre></td></tr></table></figure>

<p>这样就完成了scrapy在win下python3下的安装</p>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 下MySQL的安装</title>
    <url>/2021/05/08/2018/01/setup-mysql-inubuntu/</url>
    <content><![CDATA[<p>1， 打开终端：</p>
<blockquote>
<p> sudo apt-get install mysql-server</p>
</blockquote>
<span id="more"></span>
<p>2 ，接下来会让你选择y/n, 这里你选择y,</p>
<p>3 ，这里会出现一个让你输入mysql-server的密码，输入完后如果鼠标点击不了，可以使用Tab键+enter键继续下一步</p>
<p>4 ，接下来，会继续让我们输入一次密码</p>
<p>5， 密码输入完后，我们这里的mysql-server的用户名是：root ，密码是我们刚刚设置过的密码，</p>
<p>6， 这时候已经安装完成了，我们需要验证一下是否安装上了mysql-server</p>
<blockquote>
<p> mysql -u root -p</p>
</blockquote>
<p>按enter键后会让我们输入密码，当我们输入密码后，会出现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">snakeson@snakeson-Inspiron-<span class="number">5421</span>:~$ mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end <span class="keyword">with</span> ; or \g.</span><br><span class="line">Your MySQL connection id is <span class="number">5</span></span><br><span class="line">Server version: <span class="number">5.7</span><span class="number">.20</span>-0ubuntu0<span class="number">.16</span><span class="number">.04</span><span class="number">.1</span> (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) <span class="number">2000</span>, <span class="number">2017</span>, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark <span class="keyword">of</span> Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks <span class="keyword">of</span> their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> help. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br></pre></td></tr></table></figure>

<p>7 ， 这样我们就在Ubuntu下安装好了mysql-server。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux ubuntu16.04 工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>工作填坑之内网与外网</title>
    <url>/2021/05/08/2018/02/about-inner-outer-ip/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>内网：</p>
<blockquote>
<p>内网也就是局域网，内网的计算机以NAT（<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换</a>）协议，通过一个公共的<a href="https://baike.baidu.com/item/%E7%BD%91%E5%85%B3">网关</a>访问Internet。内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他的计算机无法向内网的计算机发送连接请求。</p>
</blockquote>
<blockquote>
<p>最直观的就是像网吧，公司内部的电脑用交换机，HUB，路由连起来的</p>
</blockquote>
<span id="more"></span>









<p>外网：</p>
<blockquote>
<p>外网IP包括：ADSL拨号的动态IP用动态<a href="https://baike.baidu.com/item/%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">解析域名</a>来绑定IP，又叫<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D">动态域名</a>；固定的外网IP(这种多半为网吧的IP)即，整个网吧的那个主IP。外网IP指的是：打开ADSL<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1">路由</a>功能的用户你的外网IP就应该是ADSL设备的IP，网吧里的外网IP是指整个网吧的主IP，校园网的外网IP就是整个校园网的那个主IP，小区网的外网IP与校园网同理，长宽的用户就要试下了，可以上论坛，看看你的IP是多少，那么那个IP就是你要绑定的，所有的内网用户都可以这样查的，论坛<br>上的IP就是你要绑定的IP</p>
</blockquote>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>第一次搭建服务器相关项目，因为第一次直接使用的是一台服务器，外网的ip，在自己的windows 是可以用mongodb 客户端与redis 客户端进行服务器上的mongodb服务端与redis服务端相连接的，并没有遇到什么困难</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>因为后台与爬虫用的同一个mongodb与redis，而那台服务器又是单核的，2g运行内存。导致mongodb老是因为连接池开得过多而被挂掉，后来就买了内网的mongodb与redis服务，一开始啥都不懂，也不知道这是一个坑，在自己本机上进行mongodb，redis测试，一直连接不上去，代码是改了又改，</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>后来老大过来了，你这是内网的，外网的当然连接不上去了，你得在腾讯云服务器上进行连接</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>后来就直接在腾讯云服务器上测试连接，然后就连好了。这个问题搞到我们三到晚上12点，确实菜，然后预料到的确实少，回过头来看下代码，一点毛病都没有啊！不知道有句mmp，该不该讲。</p>
]]></content>
      <categories>
        <category>工具软件</category>
      </categories>
      <tags>
        <tag>MongoDB Redis 工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7定时任务详解</title>
    <url>/2018/02/10/2018/02/centos-crontab/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作中需要开启一个定时任务：每天晚上2点进行爬虫代码的运行，这不得不去学习一下linux 下的定时任务crontab</p>
<span id="more"></span>
<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>yum install crontabs</p>
<p>说明：<br>/sbin/service crond start //启动服务<br>/sbin/service crond stop //关闭服务<br>/sbin/service crond restart //重启服务<br>/sbin/service crond reload //重新载入配置<br>查看crontab服务状态：service crond status<br>手动启动crontab服务：service crond start<br>查看crontab服务是否已设置为开机启动，执行命令：ntsysv<br>加入开机自动启动:<br>chkconfig crond on</p>
<h2 id="1，crontab命令"><a href="#1，crontab命令" class="headerlink" title="1，crontab命令"></a>1，crontab命令</h2><p>功能说明：设置计时器。<br>语　　法：crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab [-u &lt;用户名称&gt;][-elr]</p>
<p>补充说明：cron是一个常驻服务，它提供计时器的功能，让用户在特定的时间得以执行预设的指令或程序。只要用户会编辑计时器的配置文件，就可以使 用计时器的功能。</p>
<p>其配置文件格式如下：<br>Minute Hour Day Month DayOFWeek Command</p>
<p>参　　数：<br>-e 　编辑该用户的计时器设置。<br>-l 　列出该用户的计时器设置。<br>-r 　删除该用户的计时器设置。<br>-u&lt;用户名称&gt; 　指定要设定计时器的用户名称。</p>
<h2 id="2，crontab-格式"><a href="#2，crontab-格式" class="headerlink" title="2，crontab 格式"></a>2，crontab 格式</h2><p>基本格式 :</p>
<ul>
<li>*　 *　 *　 *　　command<br>分　时　日　月　周　 命令<br>第1列表示分钟1～59 每分钟用*或者 */1表示<br>第2列表示小时1～23（0表示0点）<br>第3列表示日期1～31<br>第4列 表示月份1～12<br>第5列标识号星期0～6（0表示星期天）<br>第6列要运行的命令<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Use the hash sign to prefix a comment</span><br><span class="line"># +—————- minute (0 – 59)</span><br><span class="line"># | +————- hour (0 – 23)</span><br><span class="line"># | | +———- day of month (1 – 31)</span><br><span class="line"># | | | +——- month (1 – 12)</span><br><span class="line"># | | | | +—- day of week (0 – 7) (Sunday=0 or 7)</span><br><span class="line"># | | | | |</span><br><span class="line"># * * * * * command to be executed</span><br></pre></td></tr></table></figure>
<h2 id="3，crontab文件的一些例子："><a href="#3，crontab文件的一些例子：" class="headerlink" title="3，crontab文件的一些例子："></a>3，crontab文件的一些例子：</h2></li>
</ul>
<blockquote>
<p>1 简单打印</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">每天早上<span class="number">6</span>点 </span><br><span class="line"><span class="number">0</span> <span class="number">6</span> * * * echo <span class="string">&quot;Good morning.&quot;</span> &gt;&gt; <span class="regexp">/tmp/</span>test.txt <span class="comment">//注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。</span></span><br><span class="line"></span><br><span class="line">每两个小时 </span><br><span class="line"><span class="number">0</span> *<span class="regexp">/2 * * * echo &quot;Have a break now.&quot; &gt;&gt; /</span>tmp/test.txt  </span><br><span class="line"></span><br><span class="line">晚上<span class="number">11</span>点到早上<span class="number">8</span>点之间每两个小时和早上八点 </span><br><span class="line"><span class="number">0</span> <span class="number">23</span>-<span class="number">7</span>/<span class="number">2</span>，<span class="number">8</span> * * * echo <span class="string">&quot;Have a good dream&quot;</span> &gt;&gt; <span class="regexp">/tmp/</span>test.txt</span><br><span class="line"></span><br><span class="line">每个月的<span class="number">4</span>号和每个礼拜的礼拜一到礼拜三的早上<span class="number">11</span>点 </span><br><span class="line"><span class="number">0</span> <span class="number">11</span> <span class="number">4</span> * <span class="number">1</span>-<span class="number">3</span> command line</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>月<span class="number">1</span>日早上<span class="number">4</span>点 </span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">1</span> <span class="number">1</span> * command line SHELL=<span class="regexp">/bin/</span>bash PATH=<span class="regexp">/sbin:/</span>bin:<span class="regexp">/usr/</span>sbin:<span class="regexp">/usr/</span>bin MAILTO=root <span class="comment">//如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/ </span></span><br><span class="line"></span><br><span class="line">每小时执行/etc/cron.hourly内的脚本</span><br><span class="line"><span class="number">01</span> * * * * root run-parts /etc/cron.hourly</span><br><span class="line"></span><br><span class="line">每天执行/etc/cron.daily内的脚本</span><br><span class="line"><span class="number">02</span> <span class="number">4</span> * * * root run-parts /etc/cron.daily </span><br><span class="line"></span><br><span class="line">每星期执行/etc/cron.weekly内的脚本</span><br><span class="line"><span class="number">22</span> <span class="number">4</span> * * <span class="number">0</span> root run-parts /etc/cron.weekly </span><br><span class="line"></span><br><span class="line">每月去执行/etc/cron.monthly内的脚本 </span><br><span class="line"><span class="number">42</span> <span class="number">4</span> <span class="number">1</span> * * root run-parts /etc/cron.monthly </span><br><span class="line"></span><br><span class="line">注意: <span class="string">&quot;run-parts&quot;</span>这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。 　 </span><br><span class="line"></span><br><span class="line">每天的下午<span class="number">4</span>点、<span class="number">5</span>点、<span class="number">6</span>点的<span class="number">5</span> min、<span class="number">15</span> min、<span class="number">25</span> min、<span class="number">35</span> min、<span class="number">45</span> min、<span class="number">55</span> min时执行命令。 </span><br><span class="line"><span class="number">5</span>，<span class="number">15</span>，<span class="number">25</span>，<span class="number">35</span>，<span class="number">45</span>，<span class="number">55</span> <span class="number">16</span>，<span class="number">17</span>，<span class="number">18</span> * * * command</span><br><span class="line"></span><br><span class="line">每周一，三，五的下午<span class="number">3</span>：<span class="number">00</span>系统进入维护状态，重新启动系统。</span><br><span class="line"><span class="number">00</span> <span class="number">15</span> * * <span class="number">1</span>，<span class="number">3</span>，<span class="number">5</span> shutdown -r +<span class="number">5</span></span><br><span class="line"></span><br><span class="line">每小时的<span class="number">10</span>分，<span class="number">40</span>分执行用户目录下的innd/bbslin这个指令： </span><br><span class="line"><span class="number">10</span>，<span class="number">40</span> * * * * innd/bbslink </span><br><span class="line"></span><br><span class="line">每小时的<span class="number">1</span>分执行用户目录下的bin/account这个指令： </span><br><span class="line"><span class="number">1</span> * * * * bin/account</span><br><span class="line"></span><br><span class="line">每天早晨三点二十分执行用户目录下如下所示的两个指令（每个指令以;分隔）： </span><br><span class="line">20 3 * * * （/bin/rm -f expire.ls logins.bad;bin/expire$#@62;expire.1st）　　</span><br><span class="line"></span><br><span class="line">每年的一月和四月，<span class="number">4</span>号到<span class="number">9</span>号的<span class="number">3</span>点<span class="number">12</span>分和<span class="number">3</span>点<span class="number">55</span>分执行/bin/rm -f expire.1st这个指令，并把结果添加在mm.txt这个文件之后（mm.txt文件位于用户自己的目录位置）。 </span><br><span class="line">12,55 3 4-9 1,4 * /bin/rm -f expire.1st$#@62;$#@62;mm.txt </span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>2 nginx示例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">30</span> <span class="number">21</span> * * * <span class="regexp">/etc/i</span>nit.d/nginx restart</span><br><span class="line">每晚的<span class="number">21</span>:<span class="number">30</span>重启 nginx。</span><br><span class="line"></span><br><span class="line"><span class="number">45</span> <span class="number">4</span> <span class="number">1</span>,<span class="number">10</span>,<span class="number">22</span> * * <span class="regexp">/etc/i</span>nit.d/nginx restart</span><br><span class="line">每月<span class="number">1</span>、 <span class="number">10</span>、<span class="number">22</span>日的<span class="number">4</span> : <span class="number">45</span>重启nginx。</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">1</span> * * <span class="number">6</span>,<span class="number">0</span> /etc/init.d/nginx restart</span><br><span class="line">每周六、周日的<span class="number">1</span> : <span class="number">10</span>重启nginx。</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>,<span class="number">30</span> <span class="number">18</span>-<span class="number">23</span> * * * <span class="regexp">/etc/i</span>nit.d/nginx restart</span><br><span class="line">每天<span class="number">18</span> : <span class="number">00</span>至<span class="number">23</span> : <span class="number">00</span>之间每隔<span class="number">30</span>分钟重启nginx。</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">23</span> * * <span class="number">6</span> /etc/init.d/nginx restart</span><br><span class="line">每星期六的<span class="number">11</span> : <span class="number">00</span> pm重启nginx。</span><br><span class="line"></span><br><span class="line">* *<span class="regexp">/1 * * * /</span>etc/init.d/nginx restart</span><br><span class="line">每一小时重启nginx</span><br><span class="line"></span><br><span class="line">* <span class="number">23</span>-<span class="number">7</span>/<span class="number">1</span> * * * <span class="regexp">/etc/i</span>nit.d/nginx restart</span><br><span class="line">晚上<span class="number">11</span>点到早上<span class="number">7</span>点之间，每 隔一小时重启nginx</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">11</span> <span class="number">4</span> * mon-wed /etc/init.d/nginx restart</span><br><span class="line">每月的<span class="number">4</span>号与每周一到周三 的<span class="number">11</span>点重启nginx</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">1</span> jan * <span class="regexp">/etc/i</span>nit.d/nginx restart</span><br><span class="line">一月一号的<span class="number">4</span>点重启nginx</span><br><span class="line"></span><br><span class="line">*<span class="regexp">/30 * * * * /u</span>sr/sbin/ntpdate <span class="number">210.72</span><span class="number">.145</span><span class="number">.20</span></span><br><span class="line">每半小时同步一下时间</span><br></pre></td></tr></table></figure>

<h2 id="4-创建cron脚本"><a href="#4-创建cron脚本" class="headerlink" title="4 创建cron脚本"></a>4 创建cron脚本</h2><ol>
<li><p>第一步：写cron脚本文件,命名为crontest.cron。<br>15,30,45,59 * * * * echo “xgmtest…..” &gt;&gt; xgmtest.txt  表示，每隔15分钟，执行打印一次命令 </p>
</li>
<li><p>第二步：添加定时任务。执行命令 “crontab crontest.cron”。搞定 </p>
</li>
<li><p>第三步：”crontab -l” 查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本</p>
</li>
</ol>
<h2 id="将脚本改为可执行（针对shell，-sh文件）"><a href="#将脚本改为可执行（针对shell，-sh文件）" class="headerlink" title="将脚本改为可执行（针对shell，.sh文件）"></a>将脚本改为可执行（针对shell，.sh文件）</h2><blockquote>
<p>chmod +x filename</p>
</blockquote>
<p>引用：</p>
<p><a href="http://blog.csdn.net/u012402276/article/details/51063269">http://blog.csdn.net/u012402276/article/details/51063269</a><br><a href="https://www.cnblogs.com/longjshz/p/5779215.html">https://www.cnblogs.com/longjshz/p/5779215.html</a><br><a href="http://blog.csdn.net/edgdvcyz/article/details/53348832">http://blog.csdn.net/edgdvcyz/article/details/53348832</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos7 crontab linux 工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Write-Ahead Log（WAL）的工作原理</title>
    <url>/2021/05/13/2021/05/WAL/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在存储系统的运行过程中，每时每刻都发生着数据的更新，背后意味着诸如创建，删除，修改文件等数据的操作。抛开物理文件数据的改变，对于中心控制节点而言，这些都会涉及到元数据的更新操作。而为了保持系统元数据和物理数据间的状态一致性，系统所有的数据操作对应的元数据变更都需要持久化到元数据db内，但其实这里有一个性能问题，我们的每次变更如果都要实时同步到外部db内，是否意味着高频的io操作？是否有延时写入的手段呢？本文将要阐述的预写式日志Write Ahead Log(WAL),正是对此的优化。</p>
<span id="more"></span>
<h2 id="Write-Ahead-Log概述"><a href="#Write-Ahead-Log概述" class="headerlink" title="Write Ahead Log概述"></a>Write Ahead Log概述</h2><p>Write Ahead Log简称WAL，在分布式存储系统中的元数据更新中应用得十分广泛。WAL的主要意思是说在将元数据的变更操作写入到持久稳定的db之前，先预先写入到一个log中，然后再由另外的操作将log apply到外部的持久db里去。这种模式会减少掉每次的db写入操作，尤其当系统要处理大量的transaction操作的时候，WAL的方式相比较于实时同步db的方式有着更高的效率。</p>
<p>WAL还有一点很重要的帮助是可以在disaster recovery过程中起到状态恢复的作用，系统在load完元数据db后，再把未来得及提交的WAL apply进来，就能恢复成和之前最终一致的状态。</p>
<h1 id="WAL的执行机理"><a href="#WAL的执行机理" class="headerlink" title="WAL的执行机理"></a>WAL的执行机理</h1><p>上面只介绍了WAL的概述内容，本小节我们来深入了解WAL的内部执行细节。</p>
<p>首先我们要搞清楚一点的是，WAL不记录元数据的本身，而是变更的record。那么何为”变更的record“？一个删除操作记录，一个添加记录，至于每个记录会包含有什么信息呢，大家可以参考audit log的内容属性。不过WAL的log格式和audit log还是有所区别的。</p>
<p>追本溯源，对于WAL来说，它是被谁写入的呢？答案是WAL buffer，当这个buffer满了的时候或者人工触发flush动作时，它就会将transaction数据写出到WAL的log内。当然，系统在每次完成一个操作时，同时会将改动应用到memory和WAL buffer内，然后自己再控制buffer flush出去的逻辑。</p>
<p>当老的WAL已经被apply进元数据db之后，我们会用更新commitId来表明当前最新的transaction，理论上来说低于这个commitId的WAL已经可以被清除purge出去了。这个过程我们可以理解为checkpoint过程，当前db+WAL变更=新的db。</p>
<p>上述WAL细节过程如下图:<br><img src="media/16208757110681/16208820219607.jpg"></p>
<h1 id="WAL-apply的控制"><a href="#WAL-apply的控制" class="headerlink" title="WAL apply的控制"></a>WAL apply的控制</h1><p>在系统做disaster recovery中，对于WAL的应用过程，有时可能会出现应用出差的情况，包括一些局部WAL记录格式写异常的情况。这个时候用户可以选择是否中断WAL的apply过程或者是忽略异常，来完成尽可能的数据状态恢复。这些都是WAL内部的细节控制。</p>
<p>以上就是本文主要阐述的关于WAL的内容了。<br>#引用<br>[1].<a href="https://pgadminedb.readthedocs.io/en/latest/module_02/">https://pgadminedb.readthedocs.io/en/latest/module_02/</a></p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>WAL</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下，cat和less显示正常，vim出现了中文乱码问题</title>
    <url>/2021/05/19/2021/05/%E5%AD%97%E7%AC%A6%E6%B7%B7%E4%B9%B1/</url>
    <content><![CDATA[<p>#一.查看文件编码格式<br>vim 文件<br>:set fileencoding<br><img src="media/16214080139603/16214094825495.jpg" alt="-w149"></p>
<span id="more"></span>
<p>正常是<br><img src="media/16214080139603/16214095062338.jpg" alt="-w215"></p>
<p>#二.处理方法<br>1.单文件更改文件格式编码<br>:e ++enc=utf-8<br>2.vim配置文件修改<br>set fence=utf8<br>这样即可</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 面向对象</title>
    <url>/2015/06/15/2015/06/JavaScript-Object-Oriented/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>面向对象程序设计（Object-oriented programming，OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。</p>
<p>——维基百科</p>
</blockquote>
<span id="more"></span>
<p>一般面向对象包含：继承，封装，多态，抽象</p>
<hr>
<h2 id="基于原型的继承"><a href="#基于原型的继承" class="headerlink" title="基于原型的继承"></a>基于原型的继承</h2><pre><code>function Foo() &#123;
    this.y = 2;
&#125;
console.log(typeof Foo.prototype); //object

Foo.prototype.x = 1;
var obj3 = new Foo();

console.log(obj3.y); //2
console.log(obj3.x); //1
</code></pre>
<p>创建函数 <code>Foo</code> 的时候，就会有一个内置的 <code>Foo.prototype</code> 属性，并且这个属性是对象。</p>
<p>在使用 <code>new Foo();</code> 创建对象实例时。<code>this</code> 会指向一个对象，并且这个对象的原型会指向 <code>Foo.prototype</code> 属性。<code>this.y = 2</code> 给这个对象赋值，并把这个对象返回。把这个对象赋值给 <code>obj3</code>。</p>
<p><code>y</code> 是 <code>obj3</code> 上的，<code>x</code> 是 <code>obj3</code> 的原型 <code>Foo.prototype</code> 上的。</p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-prototype.png" alt="prototype"></p>
<hr>
<h3 id="prototype-属性与原型"><a href="#prototype-属性与原型" class="headerlink" title="prototype 属性与原型"></a>prototype 属性与原型</h3><p>prototype 是函数对象上预设的对象属性。</p>
<p>原型是对象上的原型，通常是构造器的 prototype 属性。</p>
<hr>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><pre><code>function Person(name, age) &#123;
    this.name = name;
    this.age = age;
&#125;

Person.prototype.LEGS_NUM = 2;
Person.prototype.ARMS_NUM = 2;

Person.prototype.hi = function() &#123;
    console.log(&#39;Hi, my name is &#39; + this.name + &quot;. I&#39;m &quot; + this.age + &#39; years old now&#39;);
&#125;;

Person.prototype.walking = function() &#123;
    console.log(this.name + &#39; is walking...&#39;);
&#125;;

function Student(name, age, className) &#123;
    Person.call(this, name, age); //使 Person 中的 this 指向 Student
    this.className = className;
&#125;

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.hi = function() &#123;
    console.log(&#39;Hi, my name is &#39; + this.name + &quot;. I&#39;m &quot; + this.age + &#39; years old now, and from &#39; + this.className + &quot;.&quot;);
&#125;;

Student.prototype.learn = function(subject) &#123;
    console.log(this.name + &#39; is learning &#39; + subject + &#39; at &#39; + this.className + &#39;.&#39;);
&#125;

//test
var gao = new Student(&#39;Gao&#39;, &#39;24&#39;, &#39;Class 3123&#39;);
console.log(gao); // 这个对象的具体内容见下图
gao.hi(); //Hi, my name is Gao. I&#39;m 24 years old now, and from Class 3123.
gao.LEGS_NUM; //2
gao.walking(); //Gao is walking...
gao.learn(&#39;JavaScript&#39;); //Gao is learning JavaScript at Class 3123.
</code></pre>
<ul>
<li><code>Object.create(arg)</code> 创建一个空对象，并且这个对象的原型指向参数 <code>arg</code>。</li>
<li><code>Student.prototype.constructor = Student</code> 为了保证一致性，否则 constructor 指向 Person。</li>
</ul>
<hr>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>gao 对象的原型链：</p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-oop-gao.png" alt="Object"></p>
<p>下面通过图形展示原型链：</p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<hr>
<h4 id="Object-create-null-amp-bind-null"><a href="#Object-create-null-amp-bind-null" class="headerlink" title="Object.create(null) &amp; .bind(null)"></a><code>Object.create(null)</code> &amp; <code>.bind(null)</code></h4><p>这两种算是特例。</p>
<p><code>Object.create(null)</code> 和 <code>.bind(null)</code> 这两种方式创建出来的对象是没有 <code>prototype</code> 属性的，为 <code>undefined</code>。</p>
<hr>
<h2 id="prototype-属性"><a href="#prototype-属性" class="headerlink" title="prototype 属性"></a>prototype 属性</h2><h3 id="改变-prototype"><a href="#改变-prototype" class="headerlink" title="改变 prototype"></a>改变 prototype</h3><p>JavaScript 中的 prototype 是对象，在运行的时候可以修改。</p>
<p>给 prototype 添加或删除一些属性，是会影响到已经创建好的实例对象的。</p>
<p>但是，直接修改 prototype 属性，是不会影响到已经创建好的实例对象的。但是会影响到新的实例对象。如下代码：</p>
<pre><code>// 上接上面的代码

// 给 prototype 添加或删除一些属性
Student.prototype.x = 101;
console.log(gao.x); //101

// 直接修改 prototype 属性
Student.prototype = &#123;
    y: 2
&#125;;

// 不会影响到已创建好的实例对象
console.log(gao.x); //101
console.log(gao.y); //undefined

// 会影响到新创建的实例对象
var ying = new Student(&#39;Ying&#39;, 24, &#39;UI&#39;);
console.log(ying.x); //undefined
console.log(ying.y); //2
</code></pre>
<hr>
<h3 id="内置构造器的-prototype-属性"><a href="#内置构造器的-prototype-属性" class="headerlink" title="内置构造器的 prototype 属性"></a>内置构造器的 <code>prototype</code> 属性</h3><p>修改内置构造器的 <code>prototype</code> 属性后，在实例化这个对象后，枚举其属性时，会把修改的内置构造器的 <code>prototype</code> 属性也枚举出来，有时候这是要避免的。可用 <code>defineProperty</code> 方法解决。如下代码：</p>
<pre><code>Object.prototype.x = 1;
var obj = &#123;&#125;;
console.log(obj.x); //1
console.log(obj);

for (var k in obj) &#123;
    console.log(&#39;result---&gt;&#39; + k);
&#125;
// result---&gt;x
</code></pre>
<p>使用 <code>defineProperty</code> 后：</p>
<pre><code>Object.defineProperty(Object.prototype, &#39;x&#39;, &#123;
    writable: true,
    value: 1
&#125;);
var obj = &#123;&#125;;
console.log(obj.x);//1
console.log(obj);
for (var k in obj) &#123;
    console.log(&#39;result---&gt;&#39; + k);
&#125;
// nothing output here
</code></pre>
<p>其实也可以这样枚举，使用 <code>hasOwnProperty</code> 方法：</p>
<pre><code>for (var key in obj) &#123;
    if (obj.hasOwnProperty(key)) &#123;
        console.log(&quot;result---&gt;&quot; + key);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="创建对象-new-原型链"><a href="#创建对象-new-原型链" class="headerlink" title="创建对象-new/原型链"></a>创建对象-new/原型链</h3><p>![prototype](<a href="http://7q5cdt.com1.z0.glb.clouddn.com/blog-new">http://7q5cdt.com1.z0.glb.clouddn.com/blog-new</a> prototype.png)</p>
<hr>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><pre><code>console.log([1, 2] instanceof Array); //true
console.log([1, 2] instanceof Object); //true
console.log(new Object() instanceof Array); //false
</code></pre>
<p>左边要求是对象，右边要求是构造器或函数。它会判断：<strong>右边的构造器中的 <code>prototype</code> 属性是否出现在左边的对象的原型链上。</strong></p>
<ul>
<li><strong>注意：</strong>不同的 window 或 iframe 间的对象类型检测<strong>不能</strong>使用 <code>instanceof</code>！</li>
</ul>
<hr>
<h2 id="实现继承的方式"><a href="#实现继承的方式" class="headerlink" title="实现继承的方式"></a>实现继承的方式</h2><pre><code>function Person() &#123;&#125;

function Student() &#123;&#125;

Student.prototype = Person.prototype; //1

Student.prototype = new Person(); //2

Student.prototype = Object.create(Person.prototype); //3

Student.prototype.constructor = Student;
</code></pre>
<p>注释中：</p>
<p>1 是错误的。如果改变了 Student 就会改变 Person</p>
<p>2 可以实现继承，但是其调用了构造函数，若父类构造函数中有形参，那么传值就会比较奇怪。</p>
<p>3 是最好的方法。创建了一个空对象，并且对象的原型指向参数 Person.prototype。这样便实现了继承。同时原型链写，不向上查找。但是 <code>Object.create</code> 是ES5 中的方法，所以可以使用下列代码做兼容：</p>
<pre><code>if (!Object.create) &#123;
    Object.create = function(proto) &#123;
        function F() &#123;&#125;
        F.prototype = proto;
        return new F;
    &#125;;
&#125;
</code></pre>
<hr>
<h2 id="模拟重载"><a href="#模拟重载" class="headerlink" title="模拟重载"></a>模拟重载</h2><pre><code>function Person() &#123;
    var args = arguments;
    if (typeof args[0] === &#39;object&#39; &amp;&amp; args[0]) &#123;
        if (args[0].name) &#123;
            this.name = args[0].name;
        &#125;
        if(args[0].age)&#123;
            this.age = args[0].age;
        &#125;
    &#125; else &#123;
        if (args[0]) &#123;
            this.name = args[0];
        &#125;
        if (args[1]) &#123;
            this.age = args[1];
        &#125;
    &#125;
&#125;

//重写 toString 方法
Person.prototype.toString = function() &#123;
    console.log(&#39;name=&#39;+this.name+&#39;, age=&#39;+this.age);
&#125;;

var gao = new Person(&#123;name:&#39;Gao&#39;,age:24&#125;);
gao.toString(); // name=Gao, age=24

var ying = new Person(&#39;Ying&#39;,25);
ying.toString(); // name=Ying, age=25
</code></pre>
<p>对参数进行判断，模拟实现重载。</p>
<hr>
<h2 id="调用子类方法"><a href="#调用子类方法" class="headerlink" title="调用子类方法"></a>调用子类方法</h2><pre><code>function Person(name) &#123;
    this.name = name;
&#125;

function Student(name, className) &#123;
    this.className = className;
    Person.call(this, name); // 调用基类的构造器
&#125;

var gao = new Student(&#39;Gao&#39;, &#39;3123&#39;);
console.log(gao); // Student &#123;className: &quot;3123&quot;, name: &quot;Gao&quot;&#125;

Person.prototype.init = function() &#123;&#125;;

Student.prototype.init = function() &#123;
    // do sth...
    Person.prototype.init.apply(this, arguments); // 同时也想调用父类被覆盖的方法
&#125;;
</code></pre>
<p>主要是两种：调用父类的构造器，调用原型链上父类被覆盖的方法。</p>
<hr>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><pre><code>function ClassManager() &#123;&#125;
ClassManager.prototype.addClass = function(str) &#123;
    console.log(&#39;Class: &#39; + str + &#39; added&#39;);
    return this;
&#125;;

var manager = new ClassManager();
manager.addClass(&#39;classA&#39;).addClass(&#39;classB&#39;).addClass(&#39;classC&#39;);
// Class: classA added
// Class: classB added
// Class: classC added
</code></pre>
<p>重点在于 return this。返回这个 ClassManager 的实例。这样这个实例又可以继续调用方法。</p>
<hr>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在构造器中 <code>throw new Error(&#39;&#39;);</code> 抛异常。这样防止这个类被直接调用。</p>
<pre><code>function DetectorBase() &#123;
    throw new Error(&#39;Abstract class can not be invoked directly!&#39;);
&#125;

DetectorBase.detect = function() &#123;
    console.log(&#39;Detection starting...&#39;);
&#125;
DetectorBase.stop = function() &#123;
    console.log(&#39;Detection stopped.&#39;);
&#125;;
DetectorBase.init = function() &#123;
    throw new Error(&#39;Error&#39;);
&#125;

var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!

function LinkDetector() &#123;&#125;
LinkDetector.prototype = Object.create(DetectorBase.prototype);
LinkDetector.prototype.constructor = LinkDetector;

var l = new LinkDetector();
console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetector
l.detect(); //Uncaught TypeError: l.detect is not a function
l.init(); //Uncaught TypeError: l.init is not a function
</code></pre>
<p><code>var d = new DetectorBase();</code> 是不能实例化的，会报错</p>
<p><code>l.detect();</code> 但是这个为什么报错我就不知道了。</p>
<p>已经在原课程下提问了，期待老师的讲解。 <a href="http://www.imooc.com/qadetail/82732">抽象类中子类为什么不能调用父类的非抽象方法？</a></p>
<p>问题已经解决了，应该是老师当时的课件写错了，应该再基类中将这两个方法写在其原型 prototype 上。如下：</p>
<pre><code>function DetectorBase() &#123;
    throw new Error(&#39;Abstract class can not be invoked directly!&#39;);
&#125;

DetectorBase.prototype.detect = function() &#123;
    console.log(&#39;Detection starting...&#39;);
&#125;;
DetectorBase.prototype.stop = function() &#123;
    console.log(&#39;Detection stopped.&#39;);
&#125;;
DetectorBase.prototype.init = function() &#123;
    throw new Error(&#39;Error&#39;);
&#125;;

// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!

function LinkDetector() &#123;&#125;
LinkDetector.prototype = Object.create(DetectorBase.prototype);
LinkDetector.prototype.constructor = LinkDetector;

var l = new LinkDetector();
console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetector
l.detect(); //Detection starting...
l.init(); //Uncaught Error: Error
</code></pre>
<hr>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><pre><code>var moduleA;
moduleA = function() &#123;
    var prop = 1;

    function func() &#123;&#125;

    return &#123;
        func: func,
        prop: prop
    &#125;;
&#125;(); // 立即执行匿名函数
</code></pre>
<p>prop，func 不会被泄露到全局作用域。</p>
<p>或者另一种写法，使用 new</p>
<pre><code>moduleA = new function() &#123;
    var prop = 1;

    function func() &#123;&#125;

    this.func = func;
    this.prop = prop;
&#125;
</code></pre>
<p>更复杂的可以使用 Sea.js Kissy Require.js 模块化工具。</p>
<hr>
<p>最后补充一点设计模式相关的资料，我还没有来得及看的：</p>
<ul>
<li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns">学用 JavaScript 设计模式</a></li>
<li><a href="http://blog.jobbole.com/29454/">常用的Javascript设计模式</a></li>
<li><a href="http://developer.51cto.com/art/201109/288650_all.htm">JavaScript设计模式深入分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 作用域和作用域链</title>
    <url>/2015/05/20/2015/05/scope/</url>
    <content><![CDATA[<h2 id="JavaScript-作用域"><a href="#JavaScript-作用域" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h2><p>作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p>
<hr>
<h3 id="全局作用域-Global-Scope"><a href="#全局作用域-Global-Scope" class="headerlink" title="全局作用域(Global Scope)"></a>全局作用域(Global Scope)</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下 3 种情形拥有全局作用域。</p>
<ol>
<li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outVariable = <span class="string">&quot;我是最外层变量&quot;</span>; <span class="comment">//最外层变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//最外层函数</span></span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">&quot;内层变量&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//内层函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(inVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(outVariable); <span class="comment">//我是最外层变量</span></span><br><span class="line">outFun(); <span class="comment">//内层变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable); <span class="comment">//inVariable is not defined</span></span><br><span class="line">innerFun(); <span class="comment">//innerFun is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    variable = <span class="string">&quot;未定义直接赋值的变量&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable2 = <span class="string">&quot;内层变量2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">outFun2();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="built_in">console</span>.log(variable); <span class="comment">//未定义直接赋值的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable2); <span class="comment">//inVariable2 is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>所有window对象的属性拥有全局作用域<br> window对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等。</li>
</ol>
<h3 id="局部作用域-Local-Scope"><a href="#局部作用域-Local-Scope" class="headerlink" title="局部作用域(Local Scope)"></a>局部作用域(Local Scope)</h3><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域<br>。</p>
<p>如 1. 中的变量 <code>inVariable</code> 和函数 <code>innerFun</code> 都只拥有局部作用域。</p>
<hr>
<h3 id="再补充几个例子"><a href="#再补充几个例子" class="headerlink" title="再补充几个例子"></a>再补充几个例子</h3><ul>
<li>全局作用域，函数作用域，eval作用域</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 全局</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;<span class="comment">// 函数</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// error, b in not defined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var a = 1;&quot;</span>); <span class="comment">// eval</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript 中没有块作用域</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// item still in scope</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h2><p>在 JavaScript 中，函数也是对象，实际上，JavaScript 里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是 [[Scope]]，由 ECMA-262 标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<ol>
<li>在函数创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。</li>
<li>函数执行时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</li>
<li>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端。</li>
<li>当运行期上下文被销毁，活动对象也随之销毁。</li>
</ol>
<p>在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p>
<hr>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>举一个作用域链的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outVariable = <span class="string">&quot;我是最外层变量&quot;</span>; <span class="comment">//最外层变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//最外层函数</span></span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">&quot;内层变量&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//内层函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(inVariable);</span><br><span class="line">        <span class="keyword">var</span> tempVariable = inVariable;</span><br><span class="line">    &#125;</span><br><span class="line">    innerFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对最开始的代码稍加修改</p>
<p>其作用域链为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window</span><br><span class="line">├──outVariable</span><br><span class="line">└──outFun()</span><br><span class="line">   ├──inVariable</span><br><span class="line">   └──innerFun()</span><br><span class="line">      └──tempVariable</span><br></pre></td></tr></table></figure>

<p>对于 <code>innerFun()</code>，其作用域链包含 3 个对象：innerFun() 自己的变量对象、outFun()的变量对象、全局变量对象。</p>
<hr>
<h4 id="特例-构造器创建的函数"><a href="#特例-构造器创建的函数" class="headerlink" title="特例-构造器创建的函数"></a>特例-构造器创建的函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;console.log(typeof i);&quot;</span>);</span><br><span class="line">    func(); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>

<p>通过构造器创建的函数是访问不到外层的局部变量的。</p>
<hr>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况下会发生这种现象。</p>
<ul>
<li><code>try-catch</code> 语句中的 <code>catch</code> 块</li>
<li><code>with</code> 语句</li>
</ul>
<p>对 with 来说，将会指定对象添加到作用域链中。对 catch 来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<hr>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>
<hr>
<h2 id="VO-amp-AO"><a href="#VO-amp-AO" class="headerlink" title="VO &amp; AO"></a>VO &amp; AO</h2><h3 id="变量初始化阶段"><a href="#变量初始化阶段" class="headerlink" title="变量初始化阶段"></a>变量初始化阶段</h3><ul>
<li><p>JS解释器如何找到我们定义的函数和变量？</p>
<p>  变量对象 (Variable Object, 缩写为VO) 是一个抽象概念中的“对象”，它用于存储执行上下文中的：</p>
<ol>
<li>变量</li>
<li>函数声明</li>
<li>函数参数</li>
</ol>
</li>
<li><p>VO按照如下顺序填充:</p>
<ol>
<li>函数参数 (若未传入，初始化该参数值为undefined)    </li>
<li>函数声明 (若发生命名冲突，会覆盖)   </li>
<li>变量声明 (初始化变量值为 undefined，若发生命名冲突，会忽略。)</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">100</span>); <span class="comment">// funtion x()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo2(<span class="number">110</span>); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo3(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo4(); <span class="comment">// funtion x()</span></span><br></pre></td></tr></table></figure>

<p><strong>注：函数表达式不会影响 VO</strong></p>
<hr>
<h3 id="代码执行阶段"><a href="#代码执行阶段" class="headerlink" title="代码执行阶段"></a>代码执行阶段</h3><p>给 VO 对象内的变量赋值。</p>
<p>VO 变为 AO （活动对象 activation object）。</p>
<hr>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(x); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">alert(x); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 1</span></span><br><span class="line">alert(b); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.laruence.com/2009/05/28/863.html">鸟哥：Javascript作用域原理</a></li>
<li><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html">理解 JavaScript 作用域和作用域链</a></li>
<li><a href="http://www.imooc.com/learn/277">JavaScript 深入浅出-慕课网</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>安装php7.3.5</title>
    <url>/2021/05/08/2021/05/centos-php7.3.5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作需要使用php7.3.5做报表系统<br>本文采用编译安装</p>
<span id="more"></span>
<p>1、先安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release libxml2 libxml2-devel openssl openssl-devel bzip2 bzip2-devel libcurl libcurl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gmp gmp-devel libmcrypt libmcrypt-devel readline readline-devel libxslt libxslt-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel ncurses curl gdbm-devel db4-devel libXpm-devel libX11-devel gd-devel gmp-devel expat-devel xmlrpc-c xmlrpc-c-devel libicu-devel libmcrypt-devel libmemcached-devel libzip gcc-c++ sqlite-devel  oniguruma oniguruma-devel autoconf</span><br></pre></td></tr></table></figure>

<p>2、开始编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure \</span><br><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php \</span><br><span class="line">--exec-prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php \</span><br><span class="line">--bindir&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin \</span><br><span class="line">--sbindir&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin \</span><br><span class="line">--includedir&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;include \</span><br><span class="line">--libdir&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;lib&#x2F;php \</span><br><span class="line">--mandir&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;php&#x2F;man \</span><br><span class="line">--with-config-file-path&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;etc \</span><br><span class="line">--with-mhash \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-mysqli&#x3D;shared,mysqlnd \</span><br><span class="line">--with-pdo-mysql&#x3D;shared,mysqlnd \</span><br><span class="line">--with-gd \</span><br><span class="line">--with-iconv \</span><br><span class="line">--with-zlib \</span><br><span class="line">--enable-zip \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--disable-debug \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-shared \</span><br><span class="line">--enable-xml \</span><br><span class="line">--enable-redis\</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-calendar \</span><br><span class="line">--enable-exif \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--with-libxml-dir \</span><br><span class="line">--enable-soap \</span><br><span class="line">--without-pear \</span><br><span class="line">--with-gettext \</span><br><span class="line">--enable-session \</span><br><span class="line">--with-curl \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-bz2 \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--with-fpm-user&#x3D;nginx \</span><br><span class="line">--with-fpm-group&#x3D;nginx \</span><br><span class="line">--without-gdbm \</span><br><span class="line">--enable-fast-install \</span><br><span class="line">--disable-fileinfo</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>
<p>添加配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc</span><br><span class="line">cp php-fpm.conf.default php-fpm.conf</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.d</span><br><span class="line">cp www.conf.default www.conf</span><br></pre></td></tr></table></figure>
<p>查找当前php使用ini的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php --ini</span><br></pre></td></tr></table></figure>
<p>添加配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;php&#x2F;conf</span><br><span class="line">vim php.ini</span><br><span class="line">[PHP]</span><br><span class="line">engine &#x3D; On</span><br><span class="line">short_open_tag &#x3D; Off</span><br><span class="line">precision &#x3D; 14</span><br><span class="line">output_buffering &#x3D; 4096</span><br><span class="line">zlib.output_compression &#x3D; Off</span><br><span class="line">implicit_flush &#x3D; Off</span><br><span class="line">unserialize_callback_func &#x3D;</span><br><span class="line">serialize_precision &#x3D; -1</span><br><span class="line">disable_functions &#x3D;</span><br><span class="line">disable_classes &#x3D;</span><br><span class="line">zend.enable_gc &#x3D; On</span><br><span class="line">zend.exception_ignore_args &#x3D; Off</span><br><span class="line">expose_php &#x3D; On</span><br><span class="line">max_execution_time &#x3D; 30</span><br><span class="line">max_input_time &#x3D; 60</span><br><span class="line">memory_limit &#x3D; 128M</span><br><span class="line">error_reporting &#x3D; E_ALL</span><br><span class="line">display_errors &#x3D; On</span><br><span class="line">display_startup_errors &#x3D; On</span><br><span class="line">log_errors &#x3D; On</span><br><span class="line">log_errors_max_len &#x3D; 1024</span><br><span class="line">ignore_repeated_errors &#x3D; Off</span><br><span class="line">ignore_repeated_source &#x3D; Off</span><br><span class="line">report_memleaks &#x3D; On</span><br><span class="line">variables_order &#x3D; &quot;GPCS&quot;</span><br><span class="line">request_order &#x3D; &quot;GP&quot;</span><br><span class="line">register_argc_argv &#x3D; Off</span><br><span class="line">auto_globals_jit &#x3D; On</span><br><span class="line">post_max_size &#x3D; 8M</span><br><span class="line">auto_prepend_file &#x3D;</span><br><span class="line">auto_append_file &#x3D;</span><br><span class="line">default_mimetype &#x3D; &quot;text&#x2F;html&quot;</span><br><span class="line">default_charset &#x3D; &quot;UTF-8&quot;</span><br><span class="line">doc_root &#x3D;</span><br><span class="line">user_dir &#x3D;</span><br><span class="line">enable_dl &#x3D; Off</span><br><span class="line">file_uploads &#x3D; On</span><br><span class="line">upload_max_filesize &#x3D; 2M</span><br><span class="line">max_file_uploads &#x3D; 20</span><br><span class="line">allow_url_fopen &#x3D; On</span><br><span class="line">allow_url_include &#x3D; Off</span><br><span class="line">default_socket_timeout &#x3D; 60</span><br><span class="line">extension&#x3D;ldap</span><br><span class="line">[CLI Server]</span><br><span class="line">cli_server.color &#x3D; On</span><br><span class="line">[Date]</span><br><span class="line">[filter]</span><br><span class="line">[iconv]</span><br><span class="line">[imap]</span><br><span class="line">[intl]</span><br><span class="line">[sqlite3]</span><br><span class="line">[Pcre]</span><br><span class="line">[Pdo]</span><br><span class="line">[Pdo_mysql]</span><br><span class="line">pdo_mysql.default_socket&#x3D;</span><br><span class="line">[Phar]</span><br><span class="line">[mail function]</span><br><span class="line">SMTP &#x3D; localhost</span><br><span class="line">smtp_port &#x3D; 25</span><br><span class="line">mail.add_x_header &#x3D; Off</span><br><span class="line">[ODBC]</span><br><span class="line">odbc.allow_persistent &#x3D; On</span><br><span class="line">odbc.check_persistent &#x3D; On</span><br><span class="line">odbc.max_persistent &#x3D; -1</span><br><span class="line">odbc.max_links &#x3D; -1</span><br><span class="line">odbc.defaultlrl &#x3D; 4096</span><br><span class="line">odbc.defaultbinmode &#x3D; 1</span><br><span class="line">[MySQLi]</span><br><span class="line">mysqli.max_persistent &#x3D; -1</span><br><span class="line">mysqli.allow_persistent &#x3D; On</span><br><span class="line">mysqli.max_links &#x3D; -1</span><br><span class="line">mysqli.default_port &#x3D; 3306</span><br><span class="line">mysqli.default_socket &#x3D;</span><br><span class="line">mysqli.default_host &#x3D;</span><br><span class="line">mysqli.default_user &#x3D;</span><br><span class="line">mysqli.default_pw &#x3D;</span><br><span class="line">mysqli.reconnect &#x3D; Off</span><br><span class="line">[mysqlnd]</span><br><span class="line">mysqlnd.collect_statistics &#x3D; On</span><br><span class="line">mysqlnd.collect_memory_statistics &#x3D; On</span><br><span class="line">[OCI8]</span><br><span class="line">[PostgreSQL]</span><br><span class="line">pgsql.allow_persistent &#x3D; On</span><br><span class="line">pgsql.auto_reset_persistent &#x3D; Off</span><br><span class="line">pgsql.max_persistent &#x3D; -1</span><br><span class="line">pgsql.max_links &#x3D; -1</span><br><span class="line">pgsql.ignore_notice &#x3D; 0</span><br><span class="line">pgsql.log_notice &#x3D; 0</span><br><span class="line">[bcmath]</span><br><span class="line">bcmath.scale &#x3D; 0</span><br><span class="line">[browscap]</span><br><span class="line">[Session]</span><br><span class="line">session.save_handler &#x3D; files</span><br><span class="line">session.use_strict_mode &#x3D; 0</span><br><span class="line">session.use_cookies &#x3D; 1</span><br><span class="line">session.use_only_cookies &#x3D; 1</span><br><span class="line">session.name &#x3D; PHPSESSID</span><br><span class="line">session.auto_start &#x3D; 0</span><br><span class="line">session.cookie_lifetime &#x3D; 0</span><br><span class="line">session.cookie_path &#x3D; &#x2F;</span><br><span class="line">session.cookie_domain &#x3D;</span><br><span class="line">session.cookie_httponly &#x3D;</span><br><span class="line">session.cookie_samesite &#x3D;</span><br><span class="line">session.serialize_handler &#x3D; php</span><br><span class="line">session.gc_probability &#x3D; 1</span><br><span class="line">session.gc_divisor &#x3D; 1000</span><br><span class="line">session.gc_maxlifetime &#x3D; 1440</span><br><span class="line">session.referer_check &#x3D;</span><br><span class="line">session.cache_limiter &#x3D; nocache</span><br><span class="line">session.cache_expire &#x3D; 180</span><br><span class="line">session.use_trans_sid &#x3D; 0</span><br><span class="line">session.sid_length &#x3D; 26</span><br><span class="line">session.trans_sid_tags &#x3D; &quot;a&#x3D;href,area&#x3D;href,frame&#x3D;src,form&#x3D;&quot;</span><br><span class="line">session.sid_bits_per_character &#x3D; 5</span><br><span class="line">[Assertion]</span><br><span class="line">zend.assertions &#x3D; 1</span><br><span class="line">[COM]</span><br><span class="line">[mbstring]</span><br><span class="line">[gd]</span><br><span class="line">[exif]</span><br><span class="line">[Tidy]</span><br><span class="line">tidy.clean_output &#x3D; Off</span><br><span class="line">[soap]</span><br><span class="line">soap.wsdl_cache_enabled&#x3D;1</span><br><span class="line">soap.wsdl_cache_dir&#x3D;&quot;&#x2F;tmp&quot;</span><br><span class="line">soap.wsdl_cache_ttl&#x3D;86400</span><br><span class="line">soap.wsdl_cache_limit &#x3D; 5</span><br><span class="line">[sysvshm]</span><br><span class="line">[ldap]</span><br><span class="line">ldap.max_links &#x3D; -1</span><br><span class="line">[dba]</span><br><span class="line">[opcache]</span><br><span class="line">[curl]</span><br><span class="line">[openssl]</span><br><span class="line">[ffi]</span><br></pre></td></tr></table></figure>
<p>安装php-redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf owlient-phpredis-2.1.1-1-g90ecd17.tar.gz</span><br><span class="line">cd owlient-phpredis-90ecd17</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;phpize</span><br><span class="line">.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;php-config</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;php&#x2F;&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20060613&#x2F;</span><br><span class="line">vim php.ini</span><br><span class="line">extension_dir &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;php&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20060613&#x2F;&quot;</span><br><span class="line">extension &#x3D; redis.so</span><br></pre></td></tr></table></figure>
<p>安装php-grpc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;pecl.php.net&#x2F;get&#x2F;grpc-1.20.0.tgz</span><br><span class="line">tar -xzvf grpc-1.20.0.tgz</span><br><span class="line">cd grpc-1.20.0</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;phpize</span><br><span class="line">.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;php-config </span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">vim php.ini</span><br><span class="line">extension &#x3D; redis.so</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos7 php</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的闭包</title>
    <url>/2015/06/14/2015/06/JavaScript-closure/</url>
    <content><![CDATA[<h2 id="闭包的例子"><a href="#闭包的例子" class="headerlink" title="闭包的例子"></a>闭包的例子</h2><pre><code>function outer() &#123;
    var localVal = 30;
    return localVal;
&#125;

console.log(outer()); //30

function outer2() &#123;
    var localVal = 30;
    return function() &#123;
        return localVal;
    &#125;;
&#125;

var func = outer2();
console.log(func()); //30
</code></pre>
<p>对于第一个普通的函数，在执行过之后，它的局部变量就可以被释放。</p>
<p>对于第二个函数，<code>localVal</code> 是不能被释放的。因为调用 <code>outer2()</code> 后，返回的是匿名函数，匿名函数可以访问外部的 <code>outer2()</code> 中的局部变量，并返回了这个局部变量 localVal。当 <code>outer2()</code> 赋值给 <code>func</code> 后，再次调用 <code>func()</code>，仍能访问到局部变量 <code>localVal</code>。这种情况就是闭包。</p>
<span id="more"></span>
<hr>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p><strong>所谓闭包就是：子函数可以使用父函数中的局部变量。</strong></p>
<pre><code>  ! function() &#123;
      var localData = &quot;localData here&quot;;
      document.addEventListener(&#39;click&#39;,
          function() &#123;
              console.log(localData); //这里访问外部数据
          &#125;);
  &#125;();

  ! function() &#123;
      var localData = &quot;localData here&quot;;
      var url = &quot;http://www.baidu.com/&quot;;
      $.ajax(&#123;
          url: url,
          success: function() &#123;
              // do sth...
              console.log(localData); //这里访问外部数据
          &#125;
      &#125;);
  &#125;()
</code></pre>
</li>
</ul>
<hr>
<h2 id="常见错误之循环闭包"><a href="#常见错误之循环闭包" class="headerlink" title="常见错误之循环闭包"></a>常见错误之循环闭包</h2><p>比如我们想循环绑定点击事件</p>
<pre><code>document.body.innerHTML = &quot;&lt;div id=div1&gt;aaa&lt;/div&gt;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;;
for (var i = 1; i &lt; 4; i++) &#123;
    document.getElementById(&#39;div&#39; + i).
    addEventListener(&#39;click&#39;, function() &#123;
        alert(i); // all are 4!
    &#125;);
&#125;
</code></pre>
<p>上面的代码，我们点击任何一个 div，弹出的都是 4</p>
<p>这是因为，for 循环中的 i 是一个全局变量。这里内函数的点击事件，访问到的是循环后的 i 值，所以是 4</p>
<pre><code>document.body.innerHTML = &quot;&lt;div id=div1&gt;aaa&lt;/div&gt;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;;
for (var i = 1; i &lt; 4; i++) &#123;
    ! function(i) &#123;
        document.getElementById(&#39;div&#39; + i).
        addEventListener(&#39;click&#39;, function() &#123;
            alert(i); // 1, 2, 3
        &#125;);
    &#125;(i);
&#125;
</code></pre>
<p>这里使用了立即执行函数，并给匿名函数赋值 i，这样点击事件每一次就会访问到相应的 i。</p>
<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><pre><code>(function() &#123;
    var _userId = 9527;
    var _typeId = &quot;item&quot;;
    var exp = &#123;&#125;;

    function converter(userId) &#123;
        return +userId;
    &#125;

    exp.getUserId = function() &#123;
        return converter(_userId);
    &#125;;

    exp.getTypeId = function() &#123;
        return _typeId;
    &#125;;

    window.a = exp;
&#125;)();

console.log(a.getUserId()); //9527
console.log(a.getTypeId()); //item

console.log(a._userId); //undefined
console.log(a._typeId); //undefined
console.log(converter); //Uncaught ReferenceError: converter is not defined
</code></pre>
<p>上面的代码通过闭包实现了一个封装。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ul>
<li><p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。</p>
</li>
<li><p>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>
</li>
</ul>
<p>from 维基百科</p>
</blockquote>
<ul>
<li><p>闭包的优点</p>
<ul>
<li>灵活和方便</li>
<li>封装</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>空间浪费</li>
<li>内存泄露</li>
<li>性能消耗</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 函数</title>
    <url>/2015/06/11/2015/06/JavaScript-function/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>函数是一块JavaScript代码，被定义一次，但可执行和调用多次。</p>
<p>JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递。</p>
<p>所以我们也常叫JS中的函数为函数对象。</p>
<span id="more"></span>

<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> y === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>一般由3部分组成：</p>
<ul>
<li>函数名</li>
<li>参数列表</li>
<li>函数体</li>
</ul>
<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><ul>
<li>直接调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();</span><br></pre></td></tr></table></figure>

<ul>
<li>对象方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o.method();</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<ul>
<li>call/apply/bind</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(o);</span><br></pre></td></tr></table></figure>

<h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>就是对函数进行普通的声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><ul>
<li>将函数赋值给变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function variable</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>立即执行函数</p>
<p>  把匿名函数用括号括起来，再直接调用。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IEF(Immediately Executed Function)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>函数对象作为返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>命名式函数表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NFE(Named Function Expression)</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里大家肯定会好奇，这个函数怎么调用？到底用哪个名字呢？</p>
<p>做一个测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">nfe</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(func === nfe);</span><br><span class="line"><span class="comment">// 在 IE6~8，得到 false</span></span><br><span class="line"><span class="comment">// 在 IE9+ 及现代浏览器中 Uncaught ReferenceError: nfe is not defined</span></span><br></pre></td></tr></table></figure>

<p>那么命名函数表达式有什么使用场景呢？</p>
<ul>
<li>一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。</li>
<li>或者在递归时，使用名字调用自己。</li>
</ul>
<p>但是这两种用法都不常见。</p>
<h3 id="变量-amp-函数的声明前置"><a href="#变量-amp-函数的声明前置" class="headerlink" title="变量 &amp; 函数的声明前置"></a>变量 &amp; 函数的声明前置</h3><p>举两个例子</p>
<p>例1，函数声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2，函数表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例1中得到的结果是 3，而例2中是 <code>Uncaught TypeError: add is not a function</code>。</p>
<p>因为函数和变量在声明的时候，会被前置到当前作用域的顶端。例1将函数声明 <code>function add(a, b)</code> 前置到作用域前端，例2将声明 <code>var add</code> 前置到其作用域的前端了，并没有赋值。<strong>赋值的过程是在函数执行到响应位置的时候才进行的</strong>。</p>
<h3 id="Function-构造器"><a href="#Function-构造器" class="headerlink" title="Function 构造器"></a>Function 构造器</h3><p>除了函数声明、函数表达式。还有一种创建函数对象的方式，是使用函数构造器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;console.log(a+b);&#x27;</span>);</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func2 = <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;console.log(a+b);&#x27;</span>);</span><br><span class="line">func2(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。</p>
<p>还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-function.png" alt="函数对比"></p>
<hr>
<h2 id="函数属性-amp-arguments"><a href="#函数属性-amp-arguments" class="headerlink" title="函数属性 &amp; arguments"></a>函数属性 &amp; arguments</h2><h3 id="函数属性-amp-arguments-1"><a href="#函数属性-amp-arguments-1" class="headerlink" title="函数属性 &amp; arguments"></a>函数属性 &amp; arguments</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>.length; <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    x; <span class="comment">// change to 10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">100</span>;</span><br><span class="line">    z; <span class="comment">// still undefined!!!</span></span><br><span class="line">    <span class="built_in">arguments</span>.callee === foo; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">foo.length; <span class="comment">// 3</span></span><br><span class="line">foo.name; <span class="comment">//&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>foo.name</code> 函数名</li>
<li><code>foo.length</code> 形参个数</li>
<li><code>arguments.length</code> 实参个数</li>
</ul>
<p>未传参数时，arguments[i] 相应的位置仍然是 undefined。</p>
<p>严格模式下，代码中的改变实参失效。即 x 仍为 1。同时 callee 属性失效。</p>
<ul>
<li><p>关于 <code>callee</code></p>
<p>  callee 属性的初始值就是正被执行的 Function 对象。</p>
<p>  callee 属性是 arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或者保证函数的封装性，例如下边示例的递归计算1到n的自然数之和。而该属性仅当相关函数正在执行时才可用。还有需要注意的是callee拥有length属性，这个属性有时用于验证还是比较好的。</p>
<p>  arguments.length是实参长度，arguments.callee.length是形参长度，由此可以判断调用时形参长度是否和实参长度一致。</p>
</li>
</ul>
<h3 id="apply-call-方法（浏览器）"><a href="#apply-call-方法（浏览器）" class="headerlink" title="apply/call 方法（浏览器）"></a>apply/call 方法（浏览器）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//1 2 Number &#123;[[PrimitiveValue]]: 100&#125;</span></span><br><span class="line">foo.apply(<span class="literal">true</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">//3 4 Boolean &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line">foo.apply(<span class="literal">null</span>); <span class="comment">//undefined undefined Window</span></span><br><span class="line">foo.apply(<span class="literal">undefined</span>); <span class="comment">//undefined undefined Window</span></span><br></pre></td></tr></table></figure>

<ul>
<li>call/apply 的作用：调用一个对象的一个方法，以另一个对象替换当前对象(其实就是更改对象的内部指针，即改变对象的this指向的内容)。</li>
<li>call/apply 的第一个参数为对象，即使不是对象，也会被包装为对象。</li>
<li>call 为扁平化传参，apply 后面的参数为数组</li>
<li>传入 null/undefined 时，实际为 Window 对象</li>
<li>在严格模式下：上述代码最后两行分别输出 <code>null</code>, <code>undefined</code></li>
</ul>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h3><p><code>bind</code> 是 ES5 中提出的方法，所以浏览器支持为 IE9+ 及现代浏览器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.x = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    x: <span class="number">81</span>,</span><br><span class="line">    getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">//81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getX = <span class="built_in">module</span>.getX;</span><br><span class="line">getX(); <span class="comment">//9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetX = getX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">//81</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code> 主要用于改变函数中的 <code>this</code></p>
<ul>
<li><code>module.getX(); </code> 直接通过对象调用自己的方法，结果是 81</li>
<li><code>var getX = module.getX;</code> 将这个方法赋值给一个全局变量，这时 this 指向了 Window，所以结果为 9</li>
<li><code>var boundGetX = getX.bind(module);</code> 使用 bind 绑定了自己的对象，这样 this 仍然指向 module 对象，所以结果为 81</li>
</ul>
<h4 id="bind-与-currying"><a href="#bind-与-currying" class="headerlink" title="bind 与 currying"></a>bind 与 currying</h4><p>bind 可以使函数柯里化，那么什么是柯里化？</p>
<blockquote>
<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = add.bind(<span class="literal">undefined</span>, <span class="number">100</span>);</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//103</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func2 = func.bind(<span class="literal">undefined</span>, <span class="number">200</span>);</span><br><span class="line">func2(<span class="number">10</span>); <span class="comment">//310</span></span><br></pre></td></tr></table></figure>

<p>add 函数拥有 3 个参数。我们想先传入一个参数，再去传其他参数。</p>
<p><code>var func = add.bind(undefined, 100);</code> add 函数对象调用 bind 方法，由于不需要将 this 指向原来的 add 函数对象，所以第一个参数写为 undefined 或 null。第二个参数 100 传给了 add 函数中的形参 a，并赋值给一个新的函数对象 func。</p>
<p>这时，<code>func(1, 2)</code> 即相当于传入后两个参数，所以结果为 103。</p>
<p>同理，基于 func 可以创造一个函数 func2。它只用传最后一个参数。</p>
<h4 id="bind-与-new"><a href="#bind-与-new" class="headerlink" title="bind 与 new"></a>bind 与 new</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = foo.bind(&#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> func()); <span class="comment">//foo &#123;b: 100&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于使用了 <code>new func()</code> 这种方式创建对象，其返回值为一个对象。</p>
<p>而原函数 foo 的返回值不是对象，所以会直接忽视这个 return 方法。而是变为 <code>return this;</code>。并且 this 会被初始化为一个空对象，这个空对象的原型指向 foo.prototype。所以后面的 bind 是不起作用的。</p>
<p>这里面这个 this 对象包含一个属性 <code>b = 100</code>。所以返回的是对象 <code>&#123;b: 100&#125;</code>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 this</title>
    <url>/2015/06/12/2015/06/JavaScript-this/</url>
    <content><![CDATA[<h2 id="全局的-this"><a href="#全局的-this" class="headerlink" title="全局的 this"></a>全局的 this</h2><p>全局 this 一般指向全局对象，浏览器中的全局对象就是 <code>window</code>。</p>
<span id="more"></span>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.document === <span class="built_in">document</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">91</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//91</span></span><br></pre></td></tr></table></figure>

<h2 id="一般函数的-this"><a href="#一般函数的-this" class="headerlink" title="一般函数的 this"></a>一般函数的 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>);<span class="comment">//true, global object</span></span><br></pre></td></tr></table></figure>

<p>可以看到一般函数的 this 也指向 window，在 nodeJS 中为 global object</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;<span class="comment">//使用严格模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1() === <span class="literal">undefined</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>严格模式中，函数的 this 为 undefined</p>
<h2 id="作为对象方法的函数的-this"><a href="#作为对象方法的函数的-this" class="headerlink" title="作为对象方法的函数的 this"></a>作为对象方法的函数的 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    prop: <span class="number">37</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></span><br></pre></td></tr></table></figure>

<p>上述代码通过字面量创建对象 o。</p>
<p>f 为对象 o 的方法。这个方法的 this 指向这个对象，在这里即对象 o。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    prop: <span class="number">37</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">independent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prop;</span><br><span class="line">&#125;</span><br><span class="line">o.f = independent;</span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></span><br></pre></td></tr></table></figure>

<p>上面的代码，创建了对象 o，但是没有给对象 o，添加方法。而是通过 <code>o.f = independent</code> 临时添加了方法属性。这样这个方法中的 this 同样也指向这个对象 o。</p>
<h2 id="对象原型链上的-this"><a href="#对象原型链上的-this" class="headerlink" title="对象原型链上的 this"></a>对象原型链上的 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>var p = Object.create(o)</code> 创建的对象，p 是基于原型 o 创建出的对象。</p>
<p>p 的原型是 o，调用 f() 的时候是调用了 o 上的方法 f()，这里面的 this 是可以指向当前对象的，即对象 p。</p>
<h2 id="get-set-方法与-this"><a href="#get-set-方法与-this" class="headerlink" title="get/set 方法与 this"></a>get/set 方法与 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modulus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.re * <span class="built_in">this</span>.re + <span class="built_in">this</span>.im * <span class="built_in">this</span>.im);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    re: <span class="number">1</span>,</span><br><span class="line">    im: -<span class="number">1</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">phase</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="built_in">this</span>.im, <span class="built_in">this</span>.re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;modulus&#x27;</span>, &#123;</span><br><span class="line">    get: modulus,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.phase, o.modulus); <span class="comment">// -0.78 1.4142</span></span><br></pre></td></tr></table></figure>

<p>get/set 方法中的 this 也会指向 get/set 方法所在的对象的。</p>
<h2 id="构造器中的-this"><a href="#构造器中的-this" class="headerlink" title="构造器中的 this"></a>构造器中的 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//25</span></span><br></pre></td></tr></table></figure>

<p>new MyClass() 的时候，MyClass()中的 this 会指向一个空对象，这个对象的原型会指向 MyClass.prototype。MyClass()没有返回值或者返回为基本类型时，默认将 this 返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a: <span class="number">24</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> C2();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//24</span></span><br></pre></td></tr></table></figure>

<p>因为返回了对象，将这个对象作为返回值</p>
<h2 id="call-apply-方法与-this"><a href="#call-apply-方法与-this" class="headerlink" title="call/apply 方法与 this"></a>call/apply 方法与 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">bar.call(<span class="number">7</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="bind-方法与-this"><a href="#bind-方法与-this" class="headerlink" title="bind 方法与 this"></a>bind 方法与 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;</span><br><span class="line">    a: <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">37</span>,</span><br><span class="line">    f: f,</span><br><span class="line">    g: g</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 37, test</span></span><br></pre></td></tr></table></figure>

<p>绑定之后再调用时，仍然会按绑定时的内容走，所以 o.g() 结果是 test</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Weinre --WebApp 调试工具</title>
    <url>/2015/06/18/2015/06/weinre/</url>
    <content><![CDATA[<h2 id="什么是-weinre？"><a href="#什么是-weinre？" class="headerlink" title="什么是 weinre？"></a>什么是 weinre？</h2><p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html">weinre官网</a> 上有两句有意思的介绍：</p>
<blockquote>
<p><strong>weinre</strong> is <strong>WE</strong>b <strong>IN</strong>spector <strong>RE</strong>mote. Pronounced like the word “winery”. Or maybe like the word “weiner”. Who knows, really.</p>
<p><strong>weinre</strong> is a debugger for web pages, like FireBug (for FireFox) and Web Inspector (for WebKit-based browsers), except it’s designed to work remotely, and in particular, to allow you debug web pages on a mobile device such as a phone.</p>
</blockquote>
<span id="more"></span>




<p>上面说 weinre 是一个远程 web 调试器。说到了它的发音，还挺幽默，哈哈。</p>
<p>远程 web 调试器。先说调试器，就像火狐中的 FireBug，Chrome 中的调试器一样。就是在浏览器中按下 <code>F12</code> 出现的那个工具。但是在手机上，你没办法按 <code>F12</code>，而这个 weinre 就是在手机上的 <code>F12</code>，与传统的不同的是，它是在手机上浏览你的 web 页面，在 PC 上查看调试工具，非常方便，这就是所谓的远程。</p>
<hr>
<h2 id="为什么用-weinre？"><a href="#为什么用-weinre？" class="headerlink" title="为什么用 weinre？"></a>为什么用 weinre？</h2><p>现代浏览器中调试工具都非常强大了，可以直接模拟手机设备，为什么还要用 weinre 这么麻烦的东西呢？</p>
<p>我觉得 PC 端的浏览器虽说可以模拟，但模拟毕竟还是模拟，还只是鼠标长按滑来滑去。在开发过程中，使用手机或平板直接来感受是多么的酷，指尖在移动设备的屏幕上摩擦摩擦！给人的直观感受绝对秒杀浏览器的模拟。</p>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用一种工具之前，了解它的原理和结构是很有帮助的。weinre 作为一种远程调试工具，在结构上分为三层：</p>
<ul>
<li>目标页面（target）：被调试的页面，页面已嵌入 weinre 的远程 js，下文会介绍；</li>
<li>Debug客户端（client）：本地的 Web Inspector 调试客户端；</li>
<li>Debug服务端（agent）：一个 HTTP Server，为目标页面与 Debug 客户端建立通信。</li>
</ul>
<p>三层结构如下图所示：</p>
<p><img src="http://muellerware.org/papers/weinre/images/http-flow.png" alt="http-flow"></p>
<p>weinre 的 debug 客户端是基于 Web Inspector 开发，而 Web Inspector 只与以 WebKit 为核心的浏览器兼容，所以 Weinre 的客户端只能用 Chrome 或者 Safari 打开。</p>
<p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html">官网</a>上也有相应的平台支持说明：</p>
<ul>
<li><p>Platforms supported - debug server 服务端</p>
<p>  任何支持 node.js 的平台。</p>
</li>
<li><p>Platforms supported - debug client 客户端（跑 debugger 界面的浏览器）</p>
<ul>
<li>Google Chrome</li>
<li>Apple Safari</li>
<li>Other recent-ish WebKit-based browsers 其他基于 webkit 内核的现代浏览器</li>
</ul>
</li>
<li><p>Platforms supported - debug target 目标页面（在移动设备中调试运行的目标页面）</p>
<ul>
<li>Android Browser application</li>
<li>iOS Mobile Safari application</li>
<li>PhoneGap/Cordova</li>
<li>other</li>
</ul>
</li>
</ul>
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>weinre 是 nodeJS 的一个应用，首先要 <a href="https://nodejs.org/">安装 nodeJS 运行环境</a></p>
</li>
<li><p>使用 npm 命令，安装 weinre</p>
<pre><code> npm -g install weinre
</code></pre>
<p> 安装成功后会有类似的信息：</p>
<pre><code> C:\Users\haoyang\AppData\Roaming\npm\weinre -&gt; C:\Users\haoyang\AppData\Roaming\npm\node_modules\weinre\weinre
 weinre@2.0.0-pre-I0Z7U9OV C:\Users\haoyang\AppData\Roaming\npm\node_modules\weinre
 ├── underscore@1.7.0
 ├── nopt@3.0.2 (abbrev@1.0.7)
 └── express@2.5.11 (mime@1.2.4, qs@0.4.2, mkdirp@0.3.0, connect@1.9.2)
</code></pre>
</li>
</ol>
<hr>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>启动服务</p>
<pre><code> weinre --boundHost -all- --httpPort 8081
</code></pre>
<ul>
<li><p>–boundHost [hostname | ip address | -all-]</p>
<p>  The ip address to bind the server to.</p>
</li>
<li><p>–httpPort [portNumber]</p>
<p>  The port to run the HTTP server on.</p>
</li>
</ul>
<p> 更多配置项参考 <a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Running.html">官网的说明</a>。</p>
</li>
<li><p>启动成功后看到如下界面：</p>
<p> <img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-weinre.png" alt="weinre"></p>
</li>
<li><p>给目标页面添加一行脚本</p>
<p> 可以看到 2.中的 Target Script 说要添加一行脚本到要调试的 web 页面中。</p>
<p> Target Script</p>
<p> You can use this script to inject the weinre target code into your web page.</p>
<p> <a href="http://localhost:8081/target/target-script-min.js#anonymous">http://localhost:8081/target/target-script-min.js#anonymous</a></p>
<p> Example:</p>
<pre><code> &lt;script src=&quot;http://localhost:8081/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;
</code></pre>
<p> 这里要说明一下，要把上面的 localhost 换为本机的 ip 地址。</p>
<p> 我们可以在命令行中 使用 <code>ipconfig</code> 得到 ip 地址，如下（当然你的可能和我的不一样）：</p>
<pre><code> IPv4 地址 . . . . . . . . . . . . : 192.168.1.107
</code></pre>
<p> 即插入如下代码：</p>
<pre><code> &lt;script src=&quot;http://192.168.1.107:8081/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li><p>进入调试页面</p>
<p> PC 端访问这个地址：</p>
<p> debug client user interface:    <a href="http://localhost:8081/client/#anonymous">http://localhost:8081/client/#anonymous</a></p>
<p> 此时 target 为 none，如下图：</p>
<p> <img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-target-none.png" alt="target-none"></p>
<p> 现在我们要用手机访问同一个局域网下的这个目标页面。我们可以把要调试的页面放到这个路径下：</p>
<pre><code> C:\Users\haoyang\AppData\Roaming\npm\node_modules\weinre\web
</code></pre>
<p> 通过 <a href="http://192.168.1.107:8081/FILE_NAME">http://192.168.1.107:8081/FILE_NAME</a> 在手机上访问，就可以看到了。当然前提是同一个局域网。</p>
<p> 但是这样可能不太灵活，每次都要把目标页面放到指定的目录下。所以我们可以另外开一个服务器。</p>
<p> 我使用了基于 node.js 的 http-server 工具。将要调试的页面发布。这样我就能通过 ip 地址加端口号在手机上访问到了。</p>
<p> 我在手机上访问 <a href="http://192.168.1.107:8080/">http://192.168.1.107:8080</a> 打开要调试的页面，此时 debug client user interface 中自动检测到 target。就可以进行调试了！</p>
<p> 如下图：</p>
<p> <img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-target.png" alt="target"></p>
<p> <img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-1954958440_meitu_2.jpg" alt="phone"></p>
</li>
</ol>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/dojotoolkit/article/details/6280924">Web移动应用调试工具——Weinre</a></li>
<li><a href="http://muellerware.org/papers/weinre/manual.html">weinre - WEb INspector REmote</a></li>
<li><a href="http://blog.csdn.net/smy_yu/article/details/38922315">webapp开发调试环境–weinre配置</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>调试工具 JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 阶段总结</title>
    <url>/2015/07/09/2015/07/JavaScript-Net/</url>
    <content><![CDATA[<p>做了一张思维导图。总结这几个月对 JavaScript 的学习吧，也是一个复习。也是我目前的技能树。</p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/blog-JavaScriptNet2.png" alt="JavaScriptNet"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>同步一个fork</title>
    <url>/2015/04/12/2015/04/Syncing-a-fork/</url>
    <content><![CDATA[<p>fork 了别人的仓库后，原作者又更新了仓库，如何将自己的代码和原仓库保持一致？本文将给你解答。</p>
<span id="more"></span>




<h2 id="如何使用搜索引擎"><a href="#如何使用搜索引擎" class="headerlink" title="如何使用搜索引擎"></a>如何使用搜索引擎</h2><p>其实这个问题并不难，我又被坑了。百度搜的东西不靠谱啊，以后这种问题一定要用<strong>英文</strong>在 <a href="http://www.google.com/">Google</a> 或者 <a href="http://cn.bing.com/">Bing</a> 上搜索，这样才能搜到原汁原味的答案。就当是一个教训吧。   </p>
<p>搜索 fork sync，就可以看到 GitHub 自己的帮助文档 <a href="https://help.github.com/articles/syncing-a-fork/">Syncing a fork</a> 点进去看这篇的时候，注意到有一个 Tip: Before you can sync your fork with an upstream repository, you must <a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/">configure a remote that points to the upstream repository</a> in Git.   </p>
<p>根据这两篇文章，问题迎刃而解！   </p>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="Configuring-a-remote-for-a-fork"><a href="#Configuring-a-remote-for-a-fork" class="headerlink" title="Configuring a remote for a fork"></a>Configuring a remote for a fork</h3><ul>
<li><p>给 fork 配置一个 remote   </p>
</li>
<li><p>主要使用 <code>git remote -v</code> 查看远程状态。   </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"># origin  https:&#x2F;&#x2F;github.com&#x2F;YOUR_USERNAME&#x2F;YOUR_FORK.git (fetch)</span><br><span class="line"># origin  https:&#x2F;&#x2F;github.com&#x2F;YOUR_USERNAME&#x2F;YOUR_FORK.git (push)</span><br></pre></td></tr></table></figure>

<ul>
<li>添加一个将被同步给 fork 远程的上游仓库      </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add upstream https:&#x2F;&#x2F;github.com&#x2F;ORIGINAL_OWNER&#x2F;ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure>


<ul>
<li>再次查看状态确认是否配置成功。   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"># origin    https:&#x2F;&#x2F;github.com&#x2F;YOUR_USERNAME&#x2F;YOUR_FORK.git (fetch)</span><br><span class="line"># origin    https:&#x2F;&#x2F;github.com&#x2F;YOUR_USERNAME&#x2F;YOUR_FORK.git (push)</span><br><span class="line"># upstream  https:&#x2F;&#x2F;github.com&#x2F;ORIGINAL_OWNER&#x2F;ORIGINAL_REPOSITORY.git (fetch)</span><br><span class="line"># upstream  https:&#x2F;&#x2F;github.com&#x2F;ORIGINAL_OWNER&#x2F;ORIGINAL_REPOSITORY.git (push)</span><br></pre></td></tr></table></figure>

<h3 id="Syncing-a-fork"><a href="#Syncing-a-fork" class="headerlink" title="Syncing a fork"></a>Syncing a fork</h3><ul>
<li>从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream/master<br><code>git fetch upstream</code>    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line"># remote: Counting objects: 75, done.</span><br><span class="line"># remote: Compressing objects: 100% (53&#x2F;53), done.</span><br><span class="line"># remote: Total 62 (delta 27), reused 44 (delta 9)</span><br><span class="line"># Unpacking objects: 100% (62&#x2F;62), done.</span><br><span class="line"># From https:&#x2F;&#x2F;github.com&#x2F;ORIGINAL_OWNER&#x2F;ORIGINAL_REPOSITORY</span><br><span class="line">#  * [new branch]      master     -&gt; upstream&#x2F;master</span><br></pre></td></tr></table></figure>

<ul>
<li>切换到本地主分支(如果不在的话)<br><code>git checkout master</code>    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"># Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。<br><code>git merge upstream/master</code>      </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge upstream&#x2F;master</span><br><span class="line"># Updating a422352..5fdff0f</span><br><span class="line"># Fast-forward</span><br><span class="line">#  README                    |    9 -------</span><br><span class="line">#  README.md                 |    7 ++++++</span><br><span class="line">#  2 files changed, 7 insertions(+), 9 deletions(-)</span><br><span class="line">#  delete mode 100644 README</span><br><span class="line">#  create mode 100644 README.md</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想更新到 GitHub 的 fork 上，直接 <code>git push origin master</code> 就好了。</li>
</ul>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>前端处理动态 url 和 pushStatus 的使用</title>
    <url>/2015/12/31/2015/12/History-API/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>起因是这样的，在尝试前后端分离的这条道路上，我自己也在不断摸索，感觉要把大部分的坑都踩踩了。目前我用的技术是：</p>
<span id="more"></span>
<ul>
<li>webpack 自动构建</li>
<li>AMD 模块化 js</li>
<li>Sass 预处理 CSS</li>
<li>使用前端模板引擎 handlebars 解决动态操作将 html 拼接在 js 中的问题</li>
</ul>
<p>但最近写了一个项目类似知乎这样的多页网站。前端 url 的处理让我觉得不够优雅。我使用的是 hash 的方式处理动态 url 的，为此我专门在知乎上提了一个问题：<a href="https://www.zhihu.com/question/38802932">前端如何处理动态url？</a></p>
<p>这里我将问题描述如下：</p>
<blockquote>
<p>前后端彻底分离的情况下，页面跳转页全部由前端控制。那么如何更好的处理动态url地址？<br>例如本问题的url为<br><a href="https://www.zhihu.com/question/38802932">https://www.zhihu.com/question/38802932</a><br>这肯定是用后台路由处理的url</p>
<p>纯前端怎么处理？用hash吗，如下:<br><a href="https://www.zhihu.com/question#38802932">https://www.zhihu.com/question#38802932</a><br>那如果本页跳转，只改变hash的话，页面不会刷新。<br>使用<code>location.reload()</code>倒是可以解决。</p>
<p><strong>但总觉得这样处理不够优雅。大家在工作中是如何处理此类场景的？还是用传统的后台路由来提供动态url？</strong></p>
</blockquote>
<p>感谢郑海波和剧中人的热心回答。都提到了<code>history</code>对象中的<code>pushState</code>，这是我第一次接触到这方面的内容（顿时觉得自己真是才疏学浅）。</p>
<p>同时也有人提到了<code>pjax</code>，这个就是<code>pushState</code>+<code>Ajax</code>的封装，也很有意思。</p>
<p>下面就来研究和实践一下吧。</p>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p><code>window</code>对象通过<code>history</code>对象提供对浏览器历史记录的访问能力。它暴露了一些非常有用的方法和属性，让你在历史记录中自由前进和后退，而在 HTML5 中，更可以操纵历史记录中的数据。</p>
<h3 id="back-forward-go-length"><a href="#back-forward-go-length" class="headerlink" title="back(), forward(), go(), length"></a><code>back()</code>, <code>forward()</code>, <code>go()</code>, <code>length</code></h3><p>浏览器的历史记录就好像一个栈，最新的在最上面，较早之前看过的在下面。</p>
<p>如下图，Chrome的历史记录：</p>
<p><img src="http://ww2.sinaimg.cn/large/7011d6cfjw1ezb16fn2bfj20k008htan.jpg" alt="chrome history"></p>
<p>下面介绍怎么在这些历史记录中跳转，但要<strong>注意</strong>，上图中的浏览器历史记录和本文说的 history 还不太同。</p>
<ul>
<li><p><code>back()</code></p>
<p>  在历史记录中后退</p>
<pre><code>  history.back();
</code></pre>
</li>
<li><p><code>forward()</code></p>
<p>  在历史记录中前进</p>
<pre><code>  history.forward();
</code></pre>
</li>
<li><p><code>go()</code></p>
<p>  移动到指定的历史记录点</p>
<pre><code>  history.go(-1);
</code></pre>
<p>  通过指定一个相对于当前页面位置的数值，你可以使用go()方法从当前会话的历史记录中加载页面（当前页面位置索引值为0，上一页就是-1，下一页为1）。</p>
<p>  <strong>go()不填参数或参数为go(0)时，页面会刷新，即<code>history.go()</code>或<code>history.go(0)</code>相当于<code>location.reload()</code></strong></p>
</li>
<li><p><code>length</code></p>
<p>  <code>length</code>为history的属性，显示history长度。</p>
</li>
</ul>
<p>本节在线demo见：<a href="http://gaohaoyang.github.io/history-pjax-demo/">History &amp; pjax demo</a> 源代码：<a href=""></a></p>
<p><strong>经过亲自测试，<code>history</code>对象只记录同一个 tab 页内的历史。如果是在新窗口打开的，则无效。如：在a标签中添加<code>target=&quot;_blank&quot;</code>，或按住<code>ctrl</code>点击，这类场景下，在新的tab页中，<code>history</code>对象也是新的。</strong></p>
<p><strong>且<code>history</code>对象记录的信息与是否同源也无关，所以唯一要满足的就是同一个标签页。</strong></p>
<h3 id="pushState-replaceState"><a href="#pushState-replaceState" class="headerlink" title="pushState(), replaceState()"></a><code>pushState()</code>, <code>replaceState()</code></h3><p>HTML5 引进了<code>history.pushState()</code>方法和<code>history.replaceState()</code>方法，它们允许你逐条地添加和修改历史记录条目，能够在不加载新页面的情况下没改变浏览器的URL。这些方法可以协同<code>window.onpopstate</code>事件一起工作。</p>
<p>使用<code>history.pushState()</code>会改变<code>referrer</code>的值，而在你调用方法后创建的  XMLHttpRequest 对象会在 HTTP 请求头中使用这个值。<code>referrer的</code>值则是创建  XMLHttpRequest 对象时所处的窗口的 URL。</p>
<ul>
<li><p><code>pushState(any data, string title, [string url])</code></p>
<p>  第一个参数为<code>history</code>对象的<code>state</code>属性值，可以放任意数据，记录历史状态。第二个参数是新状态的标题，目前浏览器基本不支持。第三个参数为可选的相对url。</p>
<p>  执行<code>pushState</code>后，可以在不加载新页面的情况下，更改url。同时<code>history</code>栈中新增一条数据。</p>
<p>  例如，我们有这样一段代码：</p>
<pre><code>  &lt;button id=&quot;push1&quot;&gt;pushState()&lt;/button&gt;

  document.querySelector(&#39;#push1&#39;).addEventListener(&#39;click&#39;, function() &#123;
      history.pushState(&#39;abc&#39;,&#39;pushStatePageTitle&#39;,&#39;pushState.html&#39;);
      document.querySelector(&#39;#length&#39;).innerHTML = history.length;//重新读取历史长度
  &#125;);
</code></pre>
<p>  当点击按钮的时候，页面不会刷新，但<code>url</code>地址的最后已经变为<code>pushState.html</code>。这一点非常像<code>hash</code>的作用，但比<code>hash</code>更优雅。</p>
</li>
</ul>
<ul>
<li><p><code>replaceState(any data, string title, [string url])</code></p>
<p>  与<code>pushState()</code>类似，只是在<code>history</code>栈中不是新增记录，而是替换一条记录。</p>
</li>
</ul>
<p><strong>需要注意的是：</strong><code>pushState()</code>和<code>replaceState()</code>方法存在安全方面的限制，本地测试是无效的，会报错，可以简单放到任何服务端测试，或者使用<code>http-server</code>开启简单服务器，通过访问<code>localhost</code>来查看效果。</p>
<p>本节demo见：<a href="http://gaohaoyang.github.io/history-pjax-demo/index.html">History &amp; pjax demo - pushState</a></p>
<h2 id="pjax"><a href="#pjax" class="headerlink" title="pjax"></a>pjax</h2><p>现在再看本文一开始提出的问题，如何让前端优雅的控制 url，这里就可以考虑 pjax 技术了。我们把 pushState + ajax 进行封装，合起来简称为 pjax。虽然不是什么新的技术，但概念已然不同。</p>
<p>如果不使用 pjax。我们依然可以使用<code>hash</code>来实现文本开始的需求。但会不利于 SEO，看着也不够优雅。</p>
<p>Pjax的原理十分简单。</p>
<ol>
<li>拦截 a 标签的默认跳转动作或某些按钮的点击事件。</li>
<li>使用 Ajax 请求新页面。</li>
<li>将返回的 Html 替换到页面中。</li>
<li>使用 HTML5 的<code>pushState()</code>修改Url。</li>
</ol>
<p>个人理解3中也可以仅仅请求数据，再由浏览器渲染。</p>
<p>每当同一个文档的浏览历史（即history对象）出现变化时，会触发<code>window.onpopstate</code>事件。</p>
<pre><code>window.onpopstate = function(event) &#123;
    console.log(event.state);
    console.log(location);
&#125;;
</code></pre>
<p>这样在用户点击前进后退时也可以很好的监听url，来做相应的页面渲染。</p>
<p>若用户刷新了页面，但没有相应的页面资源，这时页面就会显示不存在。所以我认为较好的方法是在写<code>pushState()</code>第三个参数的时候，写为<code>?a=1</code>这样的参数形式。<a href="https://github.com/browserstate/history.js">History.js</a> 也是这么写的。但是这样应该会多一次请求。也许使用 nodeJS 作为中间层会好一些吧。</p>
<p>对于上述的探索，不知道是不是我还不够深入，总觉得还是不够完美。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/History">MDN History</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/DOM/Manipulating_the_browser_history">MDN 操纵浏览器的历史记录</a></li>
<li><a href="https://www.zhihu.com/question/20289254">pjax 是如何工作的？ 知乎</a></li>
<li><a href="http://www.cnblogs.com/hustskyking/p/history-api-in-html5.html">PJAX的实现与应用 小胡子哥</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/03/url_hash.html">URL的井号-阮一峰</a></li>
<li><a href="http://javascript.ruanyifeng.com/bom/history.html">history对象 JavaScript 标准参考教程（alpha） 阮一峰</a></li>
<li><a href="http://www.ayqy.net/blog/pjaxpushstate-and-ajax/">Pjax(pushState and Ajax) 黯羽轻扬</a></li>
<li><a href="http://www.clanfei.com/2012/09/1646.html">操纵历史，利用HTML5 History API实现无刷新跳转 蓝飞</a></li>
<li><a href="http://segmentfault.com/a/1190000002920768">前端：将网站打造成单页面应用SPA（一） Coffce</a></li>
<li><a href="https://github.com/Coffcer/coffce-pjax">coffce-pjax</a></li>
<li><a href="https://github.com/browserstate/history.js">History.js</a></li>
<li><a href="https://github.com/defunkt/jquery-pjax">defunkt/jquery-pjax GitHub</a></li>
<li><a href="https://github.com/welefen/pjax">welefen/pjax</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>判断两个数组是否相似 (arraysSimilar)</title>
    <url>/2015/04/06/2015/04/arrays-similar/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目来自 <a href="http://imooc.com/code/5760">慕课网 JavaScript 深入浅出 1-6 编程练习</a>    </p>
<p>请在 index.html 文件中，编写 arraysSimilar 函数，实现判断传入的两个数组是否相似。具体需求：   </p>
<span id="more"></span>
<ol>
<li>数组中的成员类型相同，顺序可以不同。例如 [1, true] 与 [false, 2] 是相似的。</li>
<li>数组的长度一致。</li>
<li>类型的判断范围，需要区分: String, Boolean, Number, undefined, null, 函数, 日期, window.</li>
</ol>
<p>当以上全部满足，则返回**”判定结果:通过”<strong>，否则返回</strong>“判定结果:不通过”**。    </p>
<p>题目给出了 index.html 如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Untitled Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>   </span><br><span class="line">        /*</span><br><span class="line"><span class="javascript">         * param1 <span class="built_in">Array</span></span></span><br><span class="line"><span class="javascript">         * param2 <span class="built_in">Array</span></span></span><br><span class="line"><span class="javascript">         * <span class="keyword">return</span> <span class="literal">true</span> or <span class="literal">false</span></span></span><br><span class="line">         */</span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">arraysSimilar</span>(<span class="params">arr1, arr2</span>)</span>&#123;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;testData.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 testData.js 是测试用例，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//以下为多组测试数据</span></span><br><span class="line">    <span class="keyword">var</span> cases = [&#123;</span><br><span class="line">        arr1: [<span class="number">1</span>, <span class="literal">true</span>, <span class="literal">null</span>],</span><br><span class="line">        arr2: [<span class="literal">null</span>, <span class="literal">false</span>, <span class="number">100</span>],</span><br><span class="line">        expect: <span class="literal">true</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">            <span class="number">100</span></span><br><span class="line">        ],</span><br><span class="line">        arr2: [<span class="number">100</span>, &#123;&#125;],</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [<span class="literal">null</span>, <span class="number">999</span>],</span><br><span class="line">        arr2: [&#123;&#125;,</span><br><span class="line">            <span class="number">444</span></span><br><span class="line">        ],</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [<span class="built_in">window</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">&quot;hahaha&quot;</span>, (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;), <span class="literal">undefined</span>],</span><br><span class="line">        arr2: [<span class="literal">undefined</span>, (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;), <span class="string">&quot;okokok&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="literal">false</span>, <span class="number">2</span>, <span class="built_in">window</span>],</span><br><span class="line">        expect: <span class="literal">true</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [<span class="keyword">new</span> <span class="built_in">Date</span>()],</span><br><span class="line">        arr2: [&#123;&#125;],</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [<span class="built_in">window</span>],</span><br><span class="line">        arr2: [&#123;&#125;],</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [<span class="literal">undefined</span>, <span class="number">1</span>],</span><br><span class="line">        arr2: [<span class="literal">null</span>, <span class="number">2</span>],</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [<span class="keyword">new</span> <span class="built_in">Object</span>, <span class="keyword">new</span> <span class="built_in">Object</span>, <span class="keyword">new</span> <span class="built_in">Object</span>],</span><br><span class="line">        arr2: [&#123;&#125;, &#123;&#125;,</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        ],</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: <span class="literal">null</span>,</span><br><span class="line">        arr2: <span class="literal">null</span>,</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: [],</span><br><span class="line">        arr2: <span class="literal">undefined</span>,</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        arr1: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        arr2: <span class="string">&quot;cba&quot;</span>,</span><br><span class="line">        expect: <span class="literal">false</span></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用for循环, 通过arraysSimilar函数验证以上数据是否相似，如相似显示“通过”,否则&quot;不通过&quot;,所以大家要完成arraysSimilar函数,具体要求，详见任务要求。    </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cases.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arraysSimilar(cases[i].arr1, cases[i].arr2) !== cases[i].expect) &#123;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">&quot;不通过！case&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;不正确！arr1=&quot;</span> + <span class="built_in">JSON</span>.stringify(cases[i].arr1) + <span class="string">&quot;, arr2=&quot;</span> + <span class="built_in">JSON</span>.stringify(cases[i].arr2) + <span class="string">&quot; 的判断结果不是&quot;</span> + cases[i].expect);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;判定结果:&quot;</span> + (result ? <span class="string">&quot;通过&quot;</span> : <span class="string">&quot;不通过&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>各位读者在看解答前也可以自己考虑一下，看看咱们的想法是否一致，期待您在本文的留言。</p>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过观察测试用例，可以发现，最后三个用例有不是数组的。所以我们可以先判断传入的参数是否是数组。<br>又因为题目中要求数组长度必须一致，这也是第二个限制条件。<br>最后再区分具体的类型。   </p>
<p>理清思路我们可以分为以下步骤：   </p>
<ol>
<li>判断传入的参数是否为数组 (使用 <code>instanceof</code> 方法)</li>
<li>检查两个数组长度是否一致</li>
<li>分别判断数组内元素的基本数据类型 (使用 <code>typeof</code> 方法)</li>
<li>因为 <code>typeof</code> 只能检查基本数据类型，对于 <code>null</code>, <code>Date</code>, <code>window</code> 返回的都是 <code>object</code>，所以使用 <code>Object.prototype.toString.apply()</code> 来检查这些对象类型，其返回值为：<code>&#39;[object Null]&#39;</code>, <code>&#39;[object Date]&#39;</code>, <code>&#39;[object global]&#39;</code></li>
<li>分别比较每个数组内元素的各种类型的个数，如果都相等，那么这两个数组是相似的。</li>
</ol>
<h3 id="具体实现代码"><a href="#具体实现代码" class="headerlink" title="具体实现代码"></a>具体实现代码</h3><p>JavaScript代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * =====================================================</span></span><br><span class="line"><span class="comment"> * 请在index.html文件中，编写arraysSimilar函数，实现判断传入的两个数组是否相似。具体需求：</span></span><br><span class="line"><span class="comment"> * 1. 数组中的成员类型相同，顺序可以不同。例如[1, true] 与 [false, 2]是相似的。</span></span><br><span class="line"><span class="comment"> * 2. 数组的长度一致。</span></span><br><span class="line"><span class="comment"> * 3. 类型的判断范围，需要区分:String, Boolean, Number, undefined, null, 函数，日期, window.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当以上全部满足，则返回&quot;判定结果:通过&quot;，否则返回&quot;判定结果:不通过&quot;。</span></span><br><span class="line"><span class="comment"> * =====================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* param1 Array</span></span><br><span class="line"><span class="comment">* param2 Array</span></span><br><span class="line"><span class="comment">* return true or false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraysSimilar</span>(<span class="params">arr1, arr2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1 <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; arr2 <span class="keyword">instanceof</span> <span class="built_in">Array</span> ) &#123;    <span class="comment">//先判断传入的是否是数组</span></span><br><span class="line">        <span class="keyword">if</span> (arr1.length == arr2.length) &#123;                    <span class="comment">//判断数组长度</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;same-length&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(arr1);</span><br><span class="line">            <span class="built_in">console</span>.log(arr2);</span><br><span class="line">            <span class="comment">//开始判断数组内部是否相似</span></span><br><span class="line">            <span class="keyword">return</span> sameLengthArraysSimilar(arr1, arr2);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//两个数组长度不同返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//传入的参数不是数组返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个等长的数组内部是否相似</span></span><br><span class="line"><span class="comment"> * 遍历数组</span></span><br><span class="line"><span class="comment"> * arr1中元素各种类型出现的个数是否和arr2中元素各种类型出现的个数相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Array&#125;</span> </span>arr1 数组1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Array&#125;</span> </span>arr2 数组2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;true,false&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameLengthArraysSimilar</span>(<span class="params">arr1,arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> numInArr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> booleanInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> booleanInArr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> funInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> funInArr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> undefinedInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> undefinedInArr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> stringInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> stringInArr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> nullInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> nullInArr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> dateInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> dateInArr2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> windowInArr1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> windowInArr2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> arr1[i] === <span class="string">&#x27;number&#x27;</span> )&#123;</span><br><span class="line">            numInArr1 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr1[i] === <span class="string">&#x27;boolean&#x27;</span>)&#123;</span><br><span class="line">            booleanInArr1 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr1[i] === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            funInArr1 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr1[i] === <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">            undefinedInArr1 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr1[i] === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">            stringInArr1 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr1[i] ===<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.apply(arr1[i]) === <span class="string">&#x27;[object Null]&#x27;</span>)&#123;</span><br><span class="line">                nullInArr1 ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.apply(arr1[i]) === <span class="string">&#x27;[object Date]&#x27;</span>)&#123;</span><br><span class="line">                dateInArr1 ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.apply(arr1[i]) === <span class="string">&#x27;[object global]&#x27;</span>)&#123;</span><br><span class="line">                windowInArr1 ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> arr2[i] === <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">            numInArr2 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr2[i] === <span class="string">&#x27;boolean&#x27;</span>)&#123;</span><br><span class="line">            booleanInArr2 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr2[i] === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            funInArr2 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr2[i] === <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">            undefinedInArr2 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr2[i] === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">            stringInArr2 ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arr2[i] ===<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.apply(arr2[i]) === <span class="string">&#x27;[object Null]&#x27;</span>)&#123;</span><br><span class="line">                nullInArr2 ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.apply(arr2[i]) === <span class="string">&#x27;[object Date]&#x27;</span>)&#123;</span><br><span class="line">                dateInArr2 ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.apply(arr2[i]) === <span class="string">&#x27;[object global]&#x27;</span>)&#123;</span><br><span class="line">                windowInArr2 ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;num---&quot;</span>+numInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;num---&quot;</span>+numInArr2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;boo---&quot;</span>+booleanInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;boo---&quot;</span>+booleanInArr2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;null---&quot;</span>+nullInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;null---&quot;</span>+nullInArr2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;window---&quot;</span>+windowInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;window---&quot;</span>+windowInArr2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;date---&quot;</span>+dateInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;date---&quot;</span>+dateInArr2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;string---&quot;</span>+stringInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;string---&quot;</span>+stringInArr2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fun---&quot;</span>+funInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fun---&quot;</span>+funInArr2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;undefined---&quot;</span>+undefinedInArr1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;undefined---&quot;</span>+undefinedInArr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(numInArr1 == numInArr2 &amp;&amp; booleanInArr1==booleanInArr2 &amp;&amp; funInArr1==funInArr2 &amp;&amp; undefinedInArr1==undefinedInArr2 &amp;&amp; stringInArr1==stringInArr2 &amp;&amp; nullInArr1==nullInArr2 &amp;&amp; dateInArr1==dateInArr2 &amp;&amp; windowInArr1==windowInArr2)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;================================true&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;================================false&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>上述代码完美的跑完所有的测试用例，读者 <a href="http://gaohaoyang.github.io/javascript-test/arraysSimilar/">点击这里查看结果</a>，并且可以按 <code>f12</code> 看 Console 信息， 里面有代码的执行过程。  </li>
<li>当然你也可以复制本文的 JavaScript 代码，在 <a href="http://imooc.com/code/5760">慕课网的习题</a> 下跑一下，也可以看到 <code>判定结果:通过</code> 的结果</li>
<li>完整源代码在我的 GitHub <a href="https://github.com/Gaohaoyang/javascript-test/tree/master/arraysSimilar">javascript-test/arraysSimilar/</a> 仓库中   </li>
<li>其实我的代码逻辑并不复杂，有点<strong>空间换时间</strong>的感觉，执行效率应该是较高的。没有用 JavaScript 封装的任何函数，完全是自己写的。其实代码除去 <code>console.log()</code> 也并没有多少行。</li>
<li>各位读者有什么好的想法欢迎留言交流！</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web App 相关技术</title>
    <url>/2015/06/17/2015/06/web-app/</url>
    <content><![CDATA[<blockquote>
<p>往前推2到3年，前端工程师还在忧心忡忡地想，移动互联网时代下，前端是不是没有生存空间了。但今天一看，在我们团队，前端工程师超过一半的工作都是在做移动端的Web或者APP的开发。移动Web或者APP在技术本质上是和做桌面端Web没有本质区别，但是移动端的坑那是非常的多，通过学习这部分内容，让你成为一名桌面移动通吃的前端开发工程师。</p>
</blockquote>
<span id="more"></span>




<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>参考： <a href="http://junmer.github.io/mobile-dev-get-started/">移动 Web 开发入门</a></li>
</ul>
<p>上面这个 slide 资料讲的非常好，算是一个入门的介绍吧。带我们建立基本的移动 web 开发知识体系和常见问题的实践。包含以下几个方面：</p>
<ul>
<li><p>基本概念</p>
<ul>
<li><p>Native</p>
<p>  本地应用 使用 Java \ Objective-C \ Swift 开发</p>
</li>
<li><p>WebApp</p>
<p>  网页应用 html5 开发</p>
</li>
<li><p>Hybrid</p>
<p>  混合应用 ooxx(native, web)</p>
</li>
<li><p>对比</p>
</li>
</ul>
</li>
<li><p>视觉</p>
<ul>
<li>设备的像素</li>
<li>文字单位使用 rem</li>
<li>viewport 属性</li>
<li>横屏竖屏</li>
<li>Flex 伸缩布局</li>
<li>响应式设计</li>
<li>软键盘</li>
<li>隐藏地址栏</li>
<li>苹果设备添加到主屏图标</li>
</ul>
</li>
<li><p>交互</p>
<ul>
<li>Touch</li>
<li>click 延迟</li>
<li>Scroll</li>
<li>Gestures(hammer –A javascript library for multi-touch gestures)</li>
<li>手指友好设计</li>
<li>HTML5 APIS（图像，摇动，声音等）</li>
</ul>
</li>
<li><p>实践</p>
<ul>
<li>屏蔽点击元素时的阴影</li>
<li>图像（像素、矢量图标、base64 减少请求、lazyload）</li>
<li>CSS3（合理使用渐变/圆角/阴影、代替 js 动画、translate3d、解决动画闪烁）</li>
<li>localStorage</li>
<li>避免（iframe、fixed + input）</li>
<li>SPA 或 Multi page</li>
<li>can I use</li>
<li>压缩合并</li>
<li>@G/3G 下建立连接时间</li>
</ul>
</li>
<li><p>调试</p>
<ul>
<li><p>浏览器自己的调试工具，模拟手机设备</p>
</li>
<li><p>weinre</p>
<p>  关于 weinre 我写了一篇博客介绍它。<a href="http://gaohaoyang.github.io/2015/06/18/weinre/">Weinre –WebApp 调试工具</a></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="head-标签"><a href="#head-标签" class="headerlink" title="head 标签"></a>head 标签</h2><p>参考：</p>
<ul>
<li><a href="http://www.css88.com/archives/5480">移动前端不得不了解的html5 head 头标签</a></li>
</ul>
<p>上面的链接详细的讲解了：</p>
<ul>
<li><p>DOCTYPE</p>
</li>
<li><p>charset</p>
</li>
<li><p>lang属性</p>
</li>
<li><p>优先使用 IE 最新版本和 Chrome</p>
</li>
<li><p>360 使用Google Chrome Frame</p>
</li>
<li><p>SEO 优化部分：页面标题<title>标签(head 头部必须)，页面关键词 keywords，页面描述内容 description，定义网页作者 author，网页搜索引擎索引方式</p>
</li>
<li><p>为移动设备添加 viewport</p>
<p>  <code>viewport</code> 可以让布局在移动浏览器上显示的更好。 通常会写</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>* width viewport 宽度(数值/device-width)
* height viewport 高度(数值/device-height)
* initial-scale 初始缩放比例
* maximum-scale 最大缩放比例
* minimum-scale 最小缩放比例
* user-scalable 是否允许用户缩放(yes/no)
</code></pre>
<ul>
<li>ios 设备，iOS 图标，Android，Windows 8</li>
</ul>
<p><strong>总结：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cmn-Hans&quot;</span>&gt;</span> <span class="comment">&lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明文档使用的字符编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面描述 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面关键词 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 网页作者 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 搜索引擎抓取 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为移动设备添加 viewport --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- iOS 设备 begin --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置苹果工具栏颜色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 避免IE使用兼容模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 微软的老式浏览器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- UC应用模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- QQ应用模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iOS 图标 begin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/apple-touch-icon-57x57-precomposed.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;114x114&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/apple-touch-icon-114x114-precomposed.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;144x144&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/apple-touch-icon-144x144-precomposed.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iOS 图标 end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- iOS 启动画面 begin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;768x1004&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/splash-screen-768x1004.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;1536x2008&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/splash-screen-1536x2008.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;1024x748&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/Default-Portrait-1024x748.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;2048x1496&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/splash-screen-2048x1496.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 横屏 2048x1496（Retina） --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/splash-screen-320x480.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;640x960&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/splash-screen-640x960.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;640x1136&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/splash-screen-640x1136.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iOS 启动画面 end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- iOS 设备 end --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Windows 8 磁贴颜色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Windows 8 磁贴图标 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/rss+xml&quot;</span> <span class="attr">title</span>=<span class="string">&quot;RSS&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/rss.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加 RSS 订阅 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/ico&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加 favicon icon --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="页面切换动画"><a href="#页面切换动画" class="headerlink" title="页面切换动画"></a>页面切换动画</h2><ul>
<li><a href="http://www.w3cplus.com/mobile/mobile-terminal-refactoring-slider.html">移动端重构系列13——页面切换</a></li>
<li><a href="http://www.w3cplus.com/css3/css3-3d-transform.html">CSS3 3D Transform</a></li>
</ul>
<p>关于 HammerJS 的一个中文文档</p>
<ul>
<li><a href="http://www.cnblogs.com/iamlilinfeng/p/4239957.html">Hammer.js</a></li>
</ul>
<hr>
<h2 id="CSS-Processing"><a href="#CSS-Processing" class="headerlink" title="CSS Processing"></a>CSS Processing</h2><blockquote>
<p>CSS语言由于其自身语言设计的问题，加上一些浏览器兼容性问题，往往会使得我们在写它的时候，要写很多冗余代码，或者为了兼容性对同一个样式设定写好几遍。针对这些问题，诞生了CSS预处理和后处理的概念及相关方法、工具。</p>
<p>这些工具和方法帮助我们能够更加高效地书写可维护性更强的CSS代码。</p>
</blockquote>
<p>这里我尝试使用了 Sass，果然很好用。下面记录几个 sass 教程。</p>
<ul>
<li><a href="http://www.w3cplus.com/sassguide/">Sass入门-w3cplus</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html">SASS用法指南-阮一峰</a></li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先要有 ruby 环境。</p>
<p>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的 <a href="https://rubygems.org/">https://rubygems.org</a> 源，然后添加淘宝的源 <a href="https://ruby.taobao.org/%EF%BC%8C%E7%84%B6%E5%90%8E%E6%9F%A5%E7%9C%8B%E4%B8%8B%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E6%BA%90%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E6%B7%98%E5%AE%9D%E7%9A%84%EF%BC%8C%E5%88%99%E8%A1%A8%E7%A4%BA%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5">https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入</a> sass 安装命令 <code>gem install sass</code> 了。</p>
<pre><code>$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

https://ruby.taobao.org
# 请确保只有 ruby.taobao.org
$ gem install sass
</code></pre>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre><code>sass --watch style.scss:style.css --style expanded
</code></pre>
<hr>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong><code>rem</code></strong></p>
<p>字体单位使用 rem，用户在手机上设置了字体大小时，不会打破布局，造成混乱。</p>
<ul>
<li><a href="http://www.w3cplus.com/css3/define-font-size-with-css3-rem">CSS3的REM设置字体大小-w3cplus</a></li>
<li><a href="http://www.iyunlu.com/view/css-xhtml/76.html">响应式十日谈第一日：使用 rem 设置文字大小-一丝</a></li>
</ul>
<hr>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><blockquote>
<p>安全是大家经常容易忽视，但其实一旦出现影响会非常大的问题，尤其对于没有经历过企业开发，或者没有踩过坑的同学，如果等到公司工作，做实际项目后非常容易发生安全问题。</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>WEB基本攻击大致可以分为三大类：“资源枚举”、“参数操纵” 和 “其它攻击”</p>
<ul>
<li>资源枚举</li>
<li>参数操纵<ul>
<li>SQL注入</li>
<li>XPath注入</li>
<li>cgi命令执行</li>
<li>XXS（cross-site scripting跨域脚本攻击）其重点是“跨域”和“客户端执行”<ul>
<li>Reflected XSS ——基于反射的XSS攻击。主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。</li>
<li>DOM-based or local XSS——基于DOM或本地的XSS攻击</li>
<li>Stored XSS——基于存储的XSS攻击</li>
</ul>
</li>
<li>会话劫持</li>
</ul>
</li>
<li>其它攻击<ul>
<li>CSRF（cross-site request forgery）跨站请求伪造</li>
<li>钓鱼攻击指的是网站的伪造，比如ta0bao.com，然后在其中应用XSS等方式发起攻击。</li>
<li>拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。</li>
</ul>
</li>
</ul>
<h3 id="关于-XSS"><a href="#关于-XSS" class="headerlink" title="关于 XSS"></a>关于 XSS</h3><blockquote>
<p><strong>跨网站脚本</strong>（Cross-site scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p>
<p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<p>——维基百科</p>
</blockquote>
<h3 id="XSS-防护"><a href="#XSS-防护" class="headerlink" title="XSS 防护"></a>XSS 防护</h3><ol>
<li><p>浏览器解析顺序：</p>
<p> HTML Parser &gt;&gt; CSS Parser &gt;&gt; JavaScript Parser</p>
</li>
<li><p>浏览器解码顺序：</p>
<p> HTML Decoding &gt;&gt; URL Decoding &gt;&gt; JavaScript Decoding</p>
</li>
<li><p>具体的防护方式：</p>
<ul>
<li>验证输入并且基于语境和按照正确的顺序转义不可信数据<ul>
<li>HTML 中的字符串</li>
<li>HTML 属性中的字符串</li>
<li>事件句柄属性和 JavaScript 中的字符串</li>
<li>HTML 属性中的 URL 路径</li>
<li>HTML 风格属性和 CSS 中的字符串</li>
<li>JavaScript 中的 HTML</li>
</ul>
</li>
<li>始终遵循白名单优于黑名单的做法</li>
<li>不要将用户可以控制的文本放在<meta>标签前。通过使用不同的字符集注射可以导致 XSS。</li>
<li>使用 <!DOCTYPE html></li>
<li>使用推荐的 HTTP 响应头进行 XSS 防护</li>
<li>防止 CRLF 注入/HTTP 响应拆分</li>
<li>禁止 TRACE 和其他非必要方法</li>
</ul>
</li>
</ol>
<p>对于 innerHTML 的方式输出的，我们可以采用如下的方式转码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转码 XSS 防护</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;String&#125;</span> </span>str 用户输入的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span>     </span>转码后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">              .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">              .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>)</span><br><span class="line">              .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&quot;&amp;quot;&quot;</span>)</span><br><span class="line">              .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&quot;&amp;#x27;&quot;</span>)</span><br><span class="line">              .replace(<span class="regexp">/\//g</span>, <span class="string">&quot;&amp;#x2f;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/vajoy/p/4176908.html">浅谈WEB安全性（前端向）</a></li>
<li><a href="http://www.freebuf.com/articles/web/40520.html">XSS的原理分析与解剖</a></li>
<li><a href="http://www.fooying.com/chinese-translationthe-ultimate-xss-protection-cheatsheet-for-developers/">原创翻译：给开发者的终极XSS防护备忘录</a></li>
</ul>
<hr>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><blockquote>
<p>在自己做一些小项目时，可能是学校的一些网站项目，流量可能日均都不超过500，而且大多是校园局域网内访问；或者是开发一些实验室的MIS系统，这辈子你都不会去使用你开发的这个系统。在这样一些项目中，性能优化往往会被你忽略。</p>
<p>但是如果你是做一个日均PV数万、数十万、甚至更大的量级，开发的页面会被全国各地，不同网络条件的用户来进行访问。这个时候，性能问题就无法忽视了。在当今的网络条件下，如果你的页面3秒都无法完成首屏渲染，一定会让你的网站流失很多用户。</p>
<p>整个网站的性能优化有很多的环节和工作，大多数时候，不是前端工程师单独就能完成的，尤其在职能划分明确的公司中，往往需要前后端、运维、DBA等多个职位协同完成。所以，在我们的课程中，主要让你了解整个性能优化都涉及哪些方面的工作，同时，我们会专注介绍一些在前端领域可以重点关注的技术点。</p>
</blockquote>
<p>这里就是网页的打开速度，如果你的网页打开速度很慢，那么一定会有用户的流失。所以性能优化很重要。</p>
<ul>
<li>网页内容<ul>
<li>减少http请求次数</li>
<li>减少DNS查询次数</li>
<li>避免页面跳转</li>
<li>缓存Ajax</li>
<li>延迟加载</li>
<li>提前加载</li>
<li>减少DOM元素数量</li>
<li>根据域名划分内容</li>
<li>减少iframe数量</li>
<li>避免404</li>
</ul>
</li>
<li>服务器<ul>
<li>使用CDN</li>
<li>添加Expires 或Cache-Control报文头</li>
<li>Gzip压缩传输文件</li>
<li>配置ETags</li>
<li>尽早flush输出</li>
<li>使用GET Ajax请求</li>
<li>避免空的图片src</li>
</ul>
</li>
<li>Cookie<ul>
<li>减少Cookie大小</li>
<li>页面内容使用无cookie域名</li>
</ul>
</li>
<li>CSS<ul>
<li>将样式表置顶</li>
<li>避免CSS表达式</li>
<li>用&lt;link&gt;代替@import</li>
<li>避免使用Filters</li>
</ul>
</li>
<li>Javascript<ul>
<li>将脚本置底</li>
<li>使用外部Javascirpt和CSS文件</li>
<li>精简Javascript和CSS</li>
<li>去除重复脚本</li>
<li>减少DOM访问</li>
<li>使用智能事件处理</li>
</ul>
</li>
<li>图片<ul>
<li>优化图像</li>
<li>优化CSS Sprite</li>
<li>不要在HTML中缩放图片</li>
<li>使用小且可缓存的favicon.ico</li>
</ul>
</li>
<li>移动客户端<ul>
<li>保持单个内容小于25KB</li>
<li>打包组建成符合文档</li>
</ul>
</li>
</ul>
<p>具体细节参考文章：</p>
<ul>
<li><a href="http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html">毫秒必争，前端网页性能最佳实践</a></li>
</ul>
<p>我在 ToDo 这个任务中主要使用了 CDN 来加载静态资源。比如我使用了 <a href="http://cdn.code.baidu.com/">百度静态资源公共库</a>。引用了里面的 fontawesome，速度果然比在 GitHub 仓库里快很多。下一步是压缩我自己写的静态资源。</p>
<p>其他参考资料：</p>
<ul>
<li><a href="http://www.oschina.net/translate/front-end-performance-for-web-designers-and-front-end-developers#section:maximising-parallelisation">给网页设计师和前端开发者看的前端性能优化</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/?p=3152">梳理：提高前端性能方面的处理以及不足</a></li>
<li><a href="http://www.cnblogs.com/mofish/archive/2010/10/12/1849062.html">css sprite原理优缺点及使用</a></li>
<li><a href="http://www.qianduan.net/css-sprites-useful-technique-or-potential-nuisance/">CSS Sprites：鱼翅还是三鹿？</a></li>
<li><a href="http://www.cnblogs.com/leefreeman/p/3998757.html">大型网站的灵魂——性能</a></li>
<li><a href="http://web.jobbole.com/35339/">编写高效的 CSS 选择器</a></li>
</ul>
<hr>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote>
<p>对于一个复杂项目，特别是多人协作的复杂项目，如何合理划分模块，如何更加方便地进行模块加载，如何管理模块之间的依赖，是一个项目团队都会面临的问题，目前业界已经有了一些较为普遍的解决方案，如AMD。这个部分希望你能够通过学习JavaScript的模块化，学习如何合理地规划项目模块，合理使用模块化工具来优化你的项目代码结构。</p>
</blockquote>
<p>一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。</p>
<p>根据AMD规范，我们可以使用 <code>define</code> 定义模块，使用 <code>require</code> 调用模块。</p>
<p>目前，通行的 js 模块规范主要有两种：<code>CommonJS</code> 和 <code>AMD</code>。</p>
<h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p>AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是 CommonJS</p>
<p>模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。</p>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。</p>
<p>详细 API 如下：</p>
<ul>
<li><a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)">AMD（中文版）</a></li>
</ul>
<hr>
<h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。Node.JS 首先采用了 js 模块化的概念。</p>
<p>根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。</p>
<p>输出模块变量的最好方法是使用 module.exports 对象。</p>
<hr>
<h3 id="为什么要用-requireJS"><a href="#为什么要用-requireJS" class="headerlink" title="为什么要用 requireJS"></a>为什么要用 requireJS</h3><p>试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p>
<p>RequireJS就是为了解决这两个问题而诞生的：</p>
<blockquote>
<p>（1）实现js文件的异步加载，避免网页失去响应；<br>（2）管理模块之间的依赖性，便于代码的编写和维护。</p>
</blockquote>
<h4 id="requireJS"><a href="#requireJS" class="headerlink" title="requireJS"></a>requireJS</h4><ul>
<li><a href="http://requirejs.org/">requireJS 官网</a></li>
<li><a href="http://www.requirejs.cn/">requireJS 中文网</a></li>
</ul>
<hr>
<h3 id="AMD和CMD"><a href="#AMD和CMD" class="headerlink" title="AMD和CMD"></a>AMD和CMD</h3><p>CMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。</p>
<blockquote>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<ul>
<li><a href="https://github.com/seajs/seajs/issues/242">CMD 模块定义规范</a></li>
</ul>
<p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</p>
<blockquote>
<p>AMD:提前执行（异步加载：依赖先执行）+延迟执行<br>CMD:延迟执行（运行到需加载，根据顺序执行）</p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">Javascript模块化编程（一）：模块的写法–阮一峰</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">Javascript模块化编程（二）：AMD规范</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html">Javascript模块化编程（三）：require.js的用法</a></li>
<li><a href="http://segmentfault.com/a/1190000000733959">详解 JavaScript 模块开发</a></li>
<li><a href="http://www.cnblogs.com/jinguangguo/archive/2013/04/06/3002515.html?utm_source=tuicool">浅谈模块化的JavaScript</a></li>
<li><a href="http://div.io/topic/430">再谈 SeaJS 与 RequireJS 的差异</a></li>
<li>玩转AMD系列 by erik@EFE<ul>
<li><a href="http://efe.baidu.com/blog/dissecting-amd-preface/">玩转AMD - 写在前面</a></li>
<li><a href="http://efe.baidu.com/blog/dissecting-amd-what/">玩转AMD - 设计思路</a></li>
<li><a href="http://efe.baidu.com/blog/dissecting-amd-how/">玩转AMD - 应用实践</a></li>
<li><a href="http://efe.baidu.com/blog/dissecting-amd-loader/">玩转AMD - Loader</a>   </li>
</ul>
</li>
</ul>
<hr>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><blockquote>
<p>业界目前有非常多的前端开发工具，完成一些开发过程中可以自动化完成的工作，提高研发效率，并且可以提高多人协作时的开发过程一致性，提高整个项目的运维效率。</p>
<p>在EFE日常工作中，我们是基于EDP，完成项目开发过程中的项目构建、包管理、调试、单测、静态检测、打包、压缩、优化、项目部署等一系列所有工作。</p>
</blockquote>
<p>注：</p>
<p>如果网络不好，可以使用 <a href="http://npm.taobao.org/">淘宝 NPM 镜像</a>。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://div.io/topic/439">前端工程与模块化框架</a></li>
<li><a href="http://mweb.baidu.com/p/baidusearch-front-end-road.html">手机百度前端工程化之路</a></li>
<li><a href="http://www.infoq.com/cn/articles/yunlong-on-fis">对话百度前端工程师张云龙：F.I.S与前端工业化</a></li>
<li><a href="https://github.com/ecomfe/edp">EDP</a></li>
<li><a href="http://www.w3cplus.com/tools/grunt-tutorial-start-grunt.html">Grunt教程——初涉Grunt</a></li>
<li><a href="http://www.open-open.com/lib/view/open1417068223049.html">gulp入门指南</a></li>
<li><a href="http://www.w3ctech.com/topic/134">Gulp开发教程（翻译）</a></li>
<li><a href="http://www.gulpjs.com.cn/">Gulp 中文网</a></li>
<li><a href="https://github.com/ericdum/mujiang.info/issues/6">npm的package.json中文文档</a></li>
</ul>
<hr>
<h2 id="最终作品"><a href="#最终作品" class="headerlink" title="最终作品"></a>最终作品</h2><p>在任务三中，做了一个 PC 端的 ToDo 应用。任务四是将它优化，以适应移动端设备。</p>
<h3 id="ToDo-WebApp-Version"><a href="#ToDo-WebApp-Version" class="headerlink" title="ToDo WebApp Version"></a>ToDo WebApp Version</h3><ul>
<li><p><a href="https://github.com/baidu-ife/ife/tree/master/task/task0004">任务四要求</a></p>
</li>
<li><p><a href="https://github.com/Gaohaoyang/ToDo-WebApp">源代码</a></p>
</li>
<li><p><a href="http://gaohaoyang.github.io/ToDo-WebApp/">在线 demo</a></p>
</li>
<li><p>手机查看 ↓ 二维码 ↓</p>
<p>  <img src="http://7q5cdt.com1.z0.glb.clouddn.com/task4-code-todoWebApp.png" alt="todoWebApp"></p>
</li>
<li><p><a href="http://gaohaoyang.github.io/">我的博客 HyG</a></p>
</li>
</ul>
<h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><ul>
<li><p><strong>数据存储</strong></p>
<p>  以 JSON 模拟数据表的形式存储于 LocalStorage 中</p>
<pre><code>   使用数据库的思想，构建3张表。
   cateJson 分类
   childCateJson 子分类
   taskJson 任务

   分类表 cate
   ----------------------
   id* | name | child(FK)
   ----------------------

   子分类表 childCate
   --------------------------------
   id* | pid(FK) | name | child(FK)
   --------------------------------

   任务表 task
   ----------------------------------------------
   ----------------------------------------------
</code></pre>
</li>
<li><p><strong>使用 <code>Sass</code> 重构了 CSS 代码</strong></p>
<p>  使用分块、继承等方式，使得代码更加清晰明了。</p>
</li>
<li><p><strong>响应式布局</strong></p>
<p>  针对手机端细节做了很多调整，更符合手机上的视觉交互习惯。</p>
</li>
<li><p><strong>加入页面切换效果</strong></p>
<p>  使用 <code>translate3d()</code>，纯 CSS3 切换动画效果。</p>
</li>
<li><p><strong>处理了 XSS 防护</strong></p>
<p>  对可能造成破坏的字符进行转码。</p>
</li>
<li><p><strong>性能优化</strong></p>
<p>  使用 CDN 处理静态资源 fontAwesome，压缩静态资源等</p>
</li>
<li><p><strong>模块化</strong></p>
<p>  使用 requireJS 模块化 JavaScript 代码。重构 JavaScript 代码。优化之前写的耦合性高的绑定事件，重新绑定事件，降低耦合性。期间根据具体需求重写了事件代理的代码。</p>
</li>
<li><p><strong>前端工程化</strong></p>
<p>  使用 gulp，自动编译 Sass，压缩 CSS 和 JavaScript 代码。并且配置了自动流程。</p>
</li>
</ul>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="webkit-tap-highlight-color-属性"><a href="#webkit-tap-highlight-color-属性" class="headerlink" title="-webkit-tap-highlight-color 属性"></a><code>-webkit-tap-highlight-color</code> 属性</h3><p>感谢 <a href="https://github.com/fiona23">fiona</a> 指出。</p>
<p>safari移动端点击的时候会闪一下加上 <code>-webkit-tap-highlight-color: transparent;</code> 就不会闪了。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.css88.com/webkit/-webkit-tap-highlight-color/"><code>-webkit-tap-highlight-color</code>  css88</a></li>
<li><a href="http://ued.ctrip.com/webkitcss/prop/tap-highlight-color.html"><code>-webkit-tap-highlight-color</code> 属性</a></li>
</ul>
<hr>
<h3 id="textarea-标签-disabled-颜色"><a href="#textarea-标签-disabled-颜色" class="headerlink" title="textarea 标签 disabled 颜色"></a>textarea 标签 disabled 颜色</h3><ul>
<li><p>为什么用 disabled 属性？</p>
<p>  因为我发现仅仅使用 readonly 属性，在 IE 下是显示光标的。于是使用 disabled。</p>
</li>
<li><p>出现的问题</p>
<p>  各家浏览器对于 disabled 属性有自己的样式设定，比如 IE 下是灰色的。苹果设备下也是。改变这些样式的方法也不是统一的。如果要兼容 Safari 必须加上</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background: #fff;</span><br><span class="line">-webkit-text-fill-color: rgba(0, 0, 0, 1);</span><br><span class="line">-webkit-opacity: 1;</span><br></pre></td></tr></table></figure>

<p>于是最终代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    -webkit-text-fill-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    -webkit-<span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参考：<a href="http://stackoverflow.com/a/4648315">Disabled input text color 中的评论</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
